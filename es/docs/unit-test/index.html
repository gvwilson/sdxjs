<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <title>Software Design by Example: Pruebas Unitarias</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  <img src="../logo.svg" alt="site logo" class="logo" />
  <a href="../">Software Design by Example</a>
</p>
<ol class="toc-chapter">
  
  <li>
    <a href="../unit-test/">
      <strong>Pruebas Unitarias</strong>
    </a>
  </li>
  
  <li>
    <a href="../file-backup/">
      Respaldo
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../license/">
      Licencia
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contributing/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../bibliography/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 1: Pruebas Unitarias</h1>


          

          
<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#absolute_error" markdown="1">absolute error</a>, <a class="gl-ref" href="../glossary/#actual_result" markdown="1">actual result (of test)</a>, <a class="gl-ref" href="../glossary/#assertion" markdown="1">assertion</a>, <a class="gl-ref" href="../glossary/#caching" markdown="1">caching</a>, <a class="gl-ref" href="../glossary/#defensive_programming" markdown="1">defensive programming</a>, <a class="gl-ref" href="../glossary/#design_pattern" markdown="1">design pattern</a>, <a class="gl-ref" href="../glossary/#dynamic_loading" markdown="1">dynamic loading</a>, <a class="gl-ref" href="../glossary/#error_test" markdown="1">error (in a test)</a>, <a class="gl-ref" href="../glossary/#exception_handler" markdown="1">exception handler</a>, <a class="gl-ref" href="../glossary/#expected_result" markdown="1">expected result (of test)</a>, <a class="gl-ref" href="../glossary/#exploratory_programming" markdown="1">exploratory programming</a>, <a class="gl-ref" href="../glossary/#fail_test" markdown="1">fail (a test)</a>, <a class="gl-ref" href="../glossary/#fixture" markdown="1">fixture</a>, <a class="gl-ref" href="../glossary/#global_variable" markdown="1">global variable</a>, <a class="gl-ref" href="../glossary/#introspection" markdown="1">introspection</a>, <a class="gl-ref" href="../glossary/#lifecycle" markdown="1">lifecycle</a>, <a class="gl-ref" href="../glossary/#pass_test" markdown="1">pass (a test)</a>, <a class="gl-ref" href="../glossary/#relative_error" markdown="1">relative error</a>, <a class="gl-ref" href="../glossary/#side_effect" markdown="1">side effect</a>, <a class="gl-ref" href="../glossary/#singleton_pattern" markdown="1">Singleton pattern</a>, <a class="gl-ref" href="../glossary/#test_runner" markdown="1">test runner</a>, <a class="gl-ref" href="../glossary/#test_subject" markdown="1">test subject</a>, <a class="gl-ref" href="../glossary/#throw_exception" markdown="1">throw (exception)</a>, <a class="gl-ref" href="../glossary/#unit_test" markdown="1">unit test</a>
</p>


          <p>Hemos escrito muchos programitas en los dos capítulos anteriores,
pero de hecho no hemos probado ninguno de ellos.
Eso está bien para <span class="ix-entry" ix-key="exploratory programming" markdown="1"><a class="gl-ref" href="../glossary/#exploratory_programming" markdown="1">programación exploratoria</a></span>,
pero si nuestro software se va a usar en lugar de solo leerlo, debemos asegurarnos que funcione.</p>
<p>Una herramienta para escribir  y ejecutar <span class="ix-entry" ix-key="unit test!requirements for" markdown="1"><a class="gl-ref" href="../glossary/#unit_test" markdown="1">pruebas unitarias</a></span> es un buen primer paso.
Esta herramienta debe:</p>
<ul>
<li>encontrar los archivos que contienen pruebas;</li>
<li>encontrar las pruebas en esos archivos;</li>
<li>ejecutar las pruebas;</li>
<li>capturar los resultados; y</li>
<li>reportar cada resultado y un resumen de esos resultados.</li>
</ul>
<p>Nuestro diseño está inspirado en herramientas como <span class="ix-entry" ix-key="Mocha" markdown="1"><a href="https://mochajs.org/">Mocha</a></span> y <span class="ix-entry" ix-key="Jest" markdown="1"><a href="https://jestjs.io/">Jest</a></span>,
los que a su vez están inspirados por herramientas hechas para otros lenguajes 
desde los 1980s <span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Meszaros2007">Meszaros2007</a>, <a class="bib-ref" href="../bibliography/#Tudose2020">Tudose2020</a>]</span>.</p>
<h2 id="unit-test-structure">Section 1.1: ¿Cómo debemos estructurar las pruebas unitarias?</h2>
<p>Como en los otros frameworks de Pruebas Unitarias,
cada prueba será una función de cero argumentos
ya que el framework puede correrlos todos de la misma manera.
Cada prueba creará una <span class="ix-entry" ix-key="fixture (in unit test);unit test!fixture" markdown="1"><a class="gl-ref" href="../glossary/#fixture" markdown="1">fixture</a></span> a ser probada
y usar <span class="ix-entry" ix-key="assertion!in unit test" markdown="1"><a class="gl-ref" href="../glossary/#assertion" markdown="1">aserciones</a></span>
para comparar el <span class="ix-entry" ix-key="actual result (in unit test);unit test!actual result" markdown="1"><a class="gl-ref" href="../glossary/#actual_result" markdown="1">resultado actual</a></span>
contra el <span class="ix-entry" ix-key="expected result (in unit test);unit test!expected result" markdown="1"><a class="gl-ref" href="../glossary/#expected_result" markdown="1">resultado esperado</a></span>.
El resultado puede ser exactamente uno de:</p>
<ul>
<li>
<p><span class="ix-entry" ix-key="pass (in unit test);unit test!pass" markdown="1"><a class="gl-ref" href="../glossary/#pass_test" markdown="1">Pase</a></span>:
    el <span class="ix-entry" ix-key="test subject (in unit test);unit test!test subject" markdown="1"><a class="gl-ref" href="../glossary/#test_subject" markdown="1">sujeto de prueba</a></span> funciona según lo esperado.</p>
</li>
<li>
<p><span class="ix-entry" ix-key="fail (in unit test);unit test!fail" markdown="1"><a class="gl-ref" href="../glossary/#fail_test" markdown="1">Falla</a></span>:
    algo falla con el sujeto de prueba.</p>
</li>
<li>
<p><span class="ix-entry" ix-key="error (in unit test);unit test!error" markdown="1"><a class="gl-ref" href="../glossary/#error_test" markdown="1">Error</a></span>:
    algo está mal con la prueba en sí,
    lo que significa que no sabemos si el sujeto de prueba funciona correctamente o no.</p>
</li>
</ul>
<p>Para que esto sirva,
necesitamos distinguir las pruebas fallidas de las erróneas.
Nuestra solución descansa en el hecho que las excepciones son objetos
y que un programa puede usar <span class="ix-entry" ix-key="introspection!in Pruebas Unitarias" markdown="1"><a class="gl-ref" href="../glossary/#introspection" markdown="1">introspección</a></span>
para determinar la clase de un objeto.
si una prueba <span class="ix-entry" ix-key="excepción!throw" markdown="1"><a class="gl-ref" href="../glossary/#throw_exception" markdown="1">arroja una excepción</a></span> cuya clase es <code>assert.AssertionError</code>,
entonces asumiremos que la excepción vino de
una de las aserciones que pusimos en la prueba como un chequeo
(<a class="fig-ref" href="../unit-test/#unit-test-mental-model">Figure 1.1</a>).
Cualquier otro tipo  de aserción indica que la prueba en sí tiene un error.</p>
<figure id="unit-test-mental-model">
  <img src="./mental-model.svg" alt="Modelo mental de Pruebas Unitarias"/>
  <figcaption markdown="1">Figure 1.1: Ejecutando pruebas que pasen, fallen, o contengan errores.</figcaption>
</figure>

<h2 id="unit-test-design">Section 1.2: ¿Cómo podemos separar registro, ejecución, y reporteo?</h2>
<p>Para empezar,
vamos a usar unas cuantas <a class="gl-ref" href="../glossary/#global_variable" markdown="1">variables globales</a> para registrar las pruebas  y sus resultados:</p>
<div class="code-sample lang-js" title="dry-run.js">
<div class="highlight"><pre><span></span><code><span class="c1">// State of tests.</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">HopeTests</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="nx">HopePass</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="nx">HopeFail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="nx">HopeError</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="w"></span>
</code></pre></div>
</div>
<p>No ejecutamos pruebas inmediatamente
porque queremos envolver cada una en nuestro propio <span class="ix-entry" ix-key="excepción!handler" markdown="1"><a class="gl-ref" href="../glossary/#exception_handler" markdown="1">manejador de excepciones</a></span>.
En su lugar,
la función <code>hopeThat</code> guarda un mensaje descriptivo y una función de retro-llamada que implemente una prueba
en el arreglo <code>HopeTest</code> .</p>
<div class="code-sample lang-js" title="dry-run.js">
<div class="highlight"><pre><span></span><code><span class="c1">// Record a single test for running later.</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">hopeThat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">message</span><span class="p">,</span><span class="w"> </span><span class="nx">callback</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">HopeTests</span><span class="p">.</span><span class="nx">push</span><span class="p">([</span><span class="nx">message</span><span class="p">,</span><span class="w"> </span><span class="nx">callback</span><span class="p">])</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</div>
<blockquote>
<h3>Independencia</h3>
<p>Ya que estamos agregando pruebas a un arreglo,
serán ejecutados en el orden que son registrados,
pero no debemos confiarnos.
Cada prueba unitaria debe trabajar independiente de otras
para que en caso de error o falla en una prueba anterior
no afecte el resultado de una posterior.</p>
</blockquote>
<p>Finalmente,
la función <code>main</code> corre todas las pruebas registradas:</p>
<div class="code-sample lang-js" title="dry-run.js">
<div class="highlight"><pre><span></span><code><span class="c1">// Run all of the tests that have been asked for and report summary.</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">HopeTests</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(([</span><span class="nx">message</span><span class="p">,</span><span class="w"> </span><span class="nx">test</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">test</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="nx">HopePass</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="w"> </span><span class="ow">instanceof</span><span class="w"> </span><span class="nx">assert</span><span class="p">.</span><span class="nx">AssertionError</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">HopeFail</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">HopeError</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>

<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`pass </span><span class="si">${</span><span class="nx">HopePass</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`fail </span><span class="si">${</span><span class="nx">HopeFail</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`error </span><span class="si">${</span><span class="nx">HopeError</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</div>
<p class="continue">Si una prueba termina sin excepción, entonces pasa.
Si una de las llamadas a <code>assert</code> dentro de la prueba crea un <code>AssertionError</code>,
la prueba falla,
y si genera otra excepción,
es un error.
Luego que corren todas las pruebas,
<code>main</code> reporta el  número de resultados de cada tipo.</p>
<p>Vamos a probar:</p>
<div class="code-sample lang-js" title="dry-run.js">
<div class="highlight"><pre><span></span><code><span class="c1">// Something to test (doesn&#39;t handle zero properly).</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">sign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">value</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">value</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mf">1</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// These two should pass.</span><span class="w"></span>
<span class="nx">hopeThat</span><span class="p">(</span><span class="s1">&#39;Sign of negative is -1&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">assert</span><span class="p">(</span><span class="nx">sign</span><span class="p">(</span><span class="o">-</span><span class="mf">3</span><span class="p">)</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">))</span><span class="w"></span>
<span class="nx">hopeThat</span><span class="p">(</span><span class="s1">&#39;Sign of positive is 1&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">assert</span><span class="p">(</span><span class="nx">sign</span><span class="p">(</span><span class="mf">19</span><span class="p">)</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span><span class="w"></span>

<span class="c1">// This one should fail.</span><span class="w"></span>
<span class="nx">hopeThat</span><span class="p">(</span><span class="s1">&#39;Sign of zero is 0&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">assert</span><span class="p">(</span><span class="nx">sign</span><span class="p">(</span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span><span class="w"></span>

<span class="c1">// This one is an error.</span><span class="w"></span>
<span class="nx">hopeThat</span><span class="p">(</span><span class="s1">&#39;Sign misspelled is error&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">assert</span><span class="p">(</span><span class="nx">sgn</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span><span class="w"></span>

<span class="c1">// Call the main driver.</span><span class="w"></span>
<span class="nx">main</span><span class="p">()</span><span class="w"></span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="dry-run.out">
<div class="highlight"><pre><span></span><code>pass 2
fail 1
error 1
</code></pre></div>
</div>
<p>Este simple &ldquo;framework&rdquo; hace lo que se espera, pero:</p>
<ol>
<li>
<p>No nos dice cuáles pruebas pasaron o fallaron.</p>
</li>
<li>
<p>Esas  variables globales deben concentrarse de algún modo
    para dejar en claro que están relacionadas.</p>
</li>
<li>
<p>No descubre pruebas por sí solo.</p>
</li>
<li>
<p>No tenemos forma de probar cosas que se supone generen <code>AssertionError</code>.
    A colocar aserciones dentro del código para revisar que se comporta correctamente
    se le llama <a class="gl-ref" href="../glossary/#defensive_programming" markdown="1">programación defensiva</a>;
    es una buena práctica,
    pero debemos asegurarnos que esas aserciones  fallen cuando deban hacerlo,
    igual que revisamos nuestros detectores de incendio de vez en cuando.</p>
</li>
</ol>
<h2 id="unit-test-registration">Section 1.3: ¿Cómo debemos estructurar el registro de pruebas?</h2>
<p>La siguiente versión de nuestra herramienta de pruebas resuelve los primeros dos problemas en el original
colocando la maquinaria de pruebas en una clase.
Usa el <a class="gl-ref" href="../glossary/#design_pattern" markdown="1">patrón de diseño</a> <span class="ix-entry" ix-key="Singleton patrón;design patrón!Singleton" markdown="1"><a class="gl-ref" href="../glossary/#singleton_pattern" markdown="1">Singleton</a></span> 
para asegurar que solo un objeto de esa clase sea creado a la vez<span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Osmani2017">Osmani2017</a>]</span>.
Los Singletons son una forma de gestionar variables globales que están relacionadas
como las que usamos para registrar las pruebas y sus resultados.
Como beneficio extra,
si decidimos luego que necesitamos varias copias de esas variables,
solo necesitamos crear más instancias de esa clase.</p>
<p>El archivo <code>hope.js</code> define la clase y exporta una instancia de ella:</p>
<div class="code-sample lang-js" title="hope.js">
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="nx">terse</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">cases</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="nx">map</span><span class="p">(([</span><span class="nx">title</span><span class="p">,</span><span class="w"> </span><span class="nx">results</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">title</span><span class="si">}</span><span class="sb">: </span><span class="si">${</span><span class="nx">results</span><span class="p">.</span><span class="nx">length</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="nx">verbose</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">report</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">title</span><span class="p">,</span><span class="w"> </span><span class="nx">results</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">cases</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">report</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">prefix</span><span class="si">}${</span><span class="nx">title</span><span class="si">}</span><span class="sb">:`</span><span class="w"></span>
<span class="w">      </span><span class="nx">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;\n&#39;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">results</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">report</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">prefix</span><span class="si">}</span><span class="sb">  </span><span class="si">${</span><span class="nx">r</span><span class="si">}</span><span class="sb">`</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">report</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="nx">cases</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="s1">&#39;passes&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">passes</span><span class="p">],</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="s1">&#39;fails&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">fails</span><span class="p">],</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="s1">&#39;errors&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">errors</span><span class="p">]]</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
</div>
<p>Esta estrategia asume dos cosas:</p>
<ol>
<li>
<p><a href="https://nodejs.org/en/">Node</a> ejecuta el código en un módulo JavaScript en cuanto lo carga,
    lo que implica que corre <code>new Hope()</code> y exporta el objeto recién creado.</p>
</li>
<li>
<p>Los módulos se guardan en el <span class="ix-entry" ix-key="cache!modules;require!caching modules" markdown="1"><a class="gl-ref" href="../glossary/#caching" markdown="1">cache</a></span> en Node
    para que un módulo dado solo cargue una vez
    sin importar cuántas veces se importa.
    Esto asegura que <code>new Hope()</code> en verdad se llama una sola vez.</p>
</li>
</ol>
<p>Una vez que un programa ha importado <code>hope</code>,
puede llamar a <code>Hope.test</code> para registrar una prueba para una ejecución posterior
y <code>Hope.run</code> para ejecutar todas las pruebas registradas hasta ese punto </p>
<figure id="unit-test-hope-structure">
  <img src="./hope-structure.svg" alt="Recording y running tests"/>
  <figcaption markdown="1">Figure 1.2: Creando un singleton, grabando pruebas, y corriéndolas.</figcaption>
</figure>

<p>Finalmente,
nuestra clase <code>Hope</code> puede reportar resultados como un resumen terso de  una-linea  y como un listado detallado.
Puede además proveer los títulos y resultados de pruebas individuales
por si alguien quiere formatearlas en una manera diferente (e.g., como HTML) puedan hacerlo:</p>
<div class="code-sample lang-js" title="hope.js">
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="nx">terse</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">cases</span><span class="p">()</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="nx">map</span><span class="p">(([</span><span class="nx">title</span><span class="p">,</span><span class="w"> </span><span class="nx">results</span><span class="p">])</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">title</span><span class="si">}</span><span class="sb">: </span><span class="si">${</span><span class="nx">results</span><span class="p">.</span><span class="nx">length</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="nx">verbose</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">report</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="nx">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">title</span><span class="p">,</span><span class="w"> </span><span class="nx">results</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">cases</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">report</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">prefix</span><span class="si">}${</span><span class="nx">title</span><span class="si">}</span><span class="sb">:`</span><span class="w"></span>
<span class="w">      </span><span class="nx">prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;\n&#39;</span><span class="w"></span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">r</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">results</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">report</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="sb">`</span><span class="si">${</span><span class="nx">prefix</span><span class="si">}</span><span class="sb">  </span><span class="si">${</span><span class="nx">r</span><span class="si">}</span><span class="sb">`</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">report</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="nx">cases</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="s1">&#39;passes&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">passes</span><span class="p">],</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="s1">&#39;fails&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">fails</span><span class="p">],</span><span class="w"></span>
<span class="w">      </span><span class="p">[</span><span class="s1">&#39;errors&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">errors</span><span class="p">]]</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
</code></pre></div>
</div>
<blockquote>
<h3>¿Quién está llamando?</h3>
<p><code>Hope.test</code> usa el módulo <span class="ix-entry" ix-key="caller module" markdown="1"><a href="https://www.npmjs.com/package/caller"><code>caller</code></a></span> 
 para recibir el nombre de la función que está registrando una prueba.
Reportar el nombre de la prueba ayuda al usuario a entender por donde iniciar depurando;
recibirlo vía introspección
en lugar de pedir al usuario pasar el nombre de la función como texto
reduciendo la escritura
y garantizando que el reporte sea exacto.
Los programadores a menudo copiarán, pegarán y modificarán pruebas;
antes o después (quizá antes), olvidarán modificar
el nombre de la función copiada y pegada que se pasa a <code>Hope.test</code>
y perderán tiempo intentando entender por qué <code>test_this</code> está fallando
cuando la falla de hecho está en <code>test_that</code>.</p>
</blockquote>
<h2 id="unit-test-cli">Section 1.4: ¿Cómo podemos crear una interfaz de línea de comandos para pruebas?</h2>
<p>La mayoría de los programadores no gozan escribiendo pruebas,
así que si queremos que lo hagan,
tiene que ser lo menos doloroso posible.
Un par de sentencias <code>import</code> para tener  <code>assert</code> y <code>hope</code>
y luego una llamada a función por prueba
es lo más simple que podemos hacer las pruebas mismas:</p>
<div class="code-sample lang-js" title="test-add.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">assert</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;assert&#39;</span><span class="w"></span>
<span class="k">import</span><span class="w"> </span><span class="nx">hope</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./hope.js&#39;</span><span class="w"></span>

<span class="nx">hope</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;Sum of 1 and 2&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">assert</span><span class="p">((</span><span class="mf">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">3</span><span class="p">))</span><span class="w"></span>
</code></pre></div>
</div>
<p>Pero eso solo define las pruebas &mdash;¿Cómo las encontraremos para ejecutarlas?
Una opción es pedirle a la gente que use <code>import</code> en cada uno de los archivos con pruebas
dentro de otro archivo:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// all-the-tests.js</span><span class="w"></span>

<span class="k">import</span><span class="w"> </span><span class="s1">&#39;./test-add.js&#39;</span><span class="w"></span>
<span class="k">import</span><span class="w"> </span><span class="s1">&#39;./test-sub.js&#39;</span><span class="w"></span>
<span class="k">import</span><span class="w"> </span><span class="s1">&#39;./test-mul.js&#39;</span><span class="w"></span>
<span class="k">import</span><span class="w"> </span><span class="s1">&#39;./test-div.js&#39;</span><span class="w"></span>

<span class="nx">Hope</span><span class="p">.</span><span class="nx">run</span><span class="p">()</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
</code></pre></div>
<p class="continue">Aquí,
<code>all-the-tests.js</code> importa otros archivos para que registren las pruebas
como un <span class="ix-entry" ix-key="side effect!for module registration" markdown="1"><a class="gl-ref" href="../glossary/#side_effect" markdown="1">efecto colateral</a></span> vía las llamadas a <code>hope.test</code>
y luego llame a <code>Hope.run</code> para ejecutarlas.
Funciona,
pero antes o después (quizá antes) alguien olvidará importar uno de los archivos de pruebas.</p>
<p>Una mejor estrategia es cargar los archivos de prueba <span class="ix-entry" ix-key="dynamic loading" markdown="1"><a class="gl-ref" href="../glossary/#dynamic_loading" markdown="1">dinámicamente</a></span>.
Mientras que  <code>import</code> se escribe usualmente como una  declaración,
también puede usarse como una función <code>async</code> 
que tome una ruta como parámetro y cargue el archivo correspondiente.
Igual que antes,
cargar archivos ejecuta el código que contienen
lo que registra las pruebas como efecto secundario:</p>
<div class="code-sample lang-js" title="pray.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">minimist</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;minimist&#39;</span><span class="w"></span>
<span class="k">import</span><span class="w"> </span><span class="nx">glob</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;glob&#39;</span><span class="w"></span>
<span class="k">import</span><span class="w"> </span><span class="nx">hope</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./hope.js&#39;</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">main</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">(</span><span class="nx">args</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">parse</span><span class="p">(</span><span class="nx">args</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">filenames</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">options</span><span class="p">.</span><span class="nx">filenames</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">glob</span><span class="p">.</span><span class="nx">sync</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">options</span><span class="p">.</span><span class="nx">root</span><span class="si">}</span><span class="sb">/**/test-*.js`</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">f</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">options</span><span class="p">.</span><span class="nx">filenames</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="k">import</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">hope</span><span class="p">.</span><span class="nx">run</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">output</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;terse&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="o">?</span><span class="w"> </span><span class="nx">hope</span><span class="p">.</span><span class="nx">terse</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="nx">hope</span><span class="p">.</span><span class="nx">verbose</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="nx">main</span><span class="p">(</span><span class="nx">process</span><span class="p">.</span><span class="nx">argv</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">2</span><span class="p">))</span><span class="w"></span>
</code></pre></div>
</div>
<p>Por defecto,
este programa encuentra todos los archivos anidados en el directorio actual
cuyos nombres coinciden con el patrón <code>test-*.js</code>
y usa una salida tersa.
Ya que podemos querer revisar los archivos en otra ubicación,
o pedir un resultado detallado,
el programa necesita manejar argumentos desde la línea de comandos.</p>
<p>El módulo <a href="https://www.npmjs.com/package/minimist"><code>minimist</code></a> hace esto
de una manera que es consistente con las convenciones en Unix.
Dados los argumentos desde la línea de comandos  <em>después</em>  del nombre del programa 
(i.e., desde <code>process.argv[2]</code> en adelante),
parece que patrones como <code>-x something</code>
y crea un objeto con opciones como claves y valores asociados a ellas.</p>
<blockquote>
<h3>Nombres  de archivos en <code>minimist</code></h3>
<p>Si usamos una línea de comandos como <code>pray.js -v something.js</code>,
entonces <code>something.js</code> se convierte en el valor de<code>-v</code>.
Para indicar que queremos agregar <code>something.js</code> a la lista de nombres de archivo restantes
asociados con la clave especial <code>_</code> (un solo guión bajo),
tenemos que escribir <code>pray.js -v -- something.js</code>.
el doble guión es una convención común en Unix  para señalar el fin de los parámetros.</p>
</blockquote>
<p>Nuestro <span class="ix-entry" ix-key="test runner;unit test!test runner" markdown="1"><a class="gl-ref" href="../glossary/#test_runner" markdown="1">ejecutor de pruebas</a></span> ahora está completo,
así que podemos probarlo con algunos archivos con pruebas que pasen, fallen, y contengan errores:</p>
<div class="code-sample lang-sh" title="pray.sh">
<div class="highlight"><pre><span></span><code>node pray.js -v
</code></pre></div>
</div>
<div class="code-sample lang-out" title="pray.out">
<div class="highlight"><pre><span></span><code>passes:
  /u/stjs/unit-test/test-add.js::Sum of 1 and 2
  /u/stjs/unit-test/test-sub.js::Difference of 1 and 2
fails:
  /u/stjs/unit-test/test-div.js::Quotient of 1 and 0
  /u/stjs/unit-test/test-mul.js::Product of 1 and 2
errors:
  /u/stjs/unit-test/test-missing.js::Sum of x and 0
</code></pre></div>
</div>
<blockquote>
<h3>El Infinito está permitido</h3>
<p><code>test-div.js</code> contiene la linea:</p>
<div class="highlight"><pre><span></span><code><span class="nx">hope</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;Quotient of 1 y 0&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">assert</span><span class="p">((</span><span class="mf">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span><span class="w"></span>
</code></pre></div>
<p>Esta prueba cuenta como una falla en lugar de un error
porque cree que el resultado de dividir entre cero es el valor especial  <code>Infinity</code>
en lugar de un error aritmético.</p>
</blockquote>
<p>Cargar módulos dinámicamente para que puedan registrar algo por nosotros para llamar más tarde 
es un patrón común en muchos lenguajes de programación.
El flujo de control va y viene entre el framework y el módulo siendo cargado
conforme esto ocurre
así que necesitamos especificar el <span class="ix-entry" ix-key="lifecycle!of unit test;unit test!lifecycle" markdown="1"><a class="gl-ref" href="../glossary/#lifecycle" markdown="1">ciclo vital</a></span> de los módulos cargados con mucho cuidado.
<a class="fig-ref" href="../unit-test/#unit-test-lifecycle">Figure 1.3</a> ilustra lo que pasa
cuando un par de archivos <code>test-add.js</code> y <code>test-sub.js</code> son cargados por nuestro framework:</p>
<ol>
<li><code>pray</code> carga <code>hope.js</code>.</li>
<li>cargando <code>hope.js</code> crea una sola instancia de la clase <code>Hope</code>.</li>
<li><code>pray</code> usa <code>glob</code> para encontrar archivos con pruebas.</li>
<li><code>pray</code> carga <code>test-add.js</code> usando <code>import</code> como función.</li>
<li>Cuando <code>test-add.js</code> corre, carga  <code>hope.js</code>.
    Ya que <code>hope.js</code> se ha cargado, esto no crea una nueva instancia de <code>Hope</code>.</li>
<li><code>test-add.js</code> usa <code>hope.test</code> para registrar una prueba (la cual aún no se ejecuta).</li>
<li><code>pray</code> entonces carga <code>test-sub.js</code>…</li>
<li>… el cual  carga <code>Hope</code>…</li>
<li>… y luego  registra una prueba.</li>
<li><code>pray</code> puede pedir a la instancia única de  <code>Hope</code> que ejecute todas las pruebas,
     luego recibe un reporte desde el singleton de <code>Hope</code>  y lo muestra.</li>
</ol>
<figure id="unit-test-lifecycle">
  <img src="./lifecycle.svg" alt="Pruebas Unitarias lifecycle"/>
  <figcaption markdown="1">Figure 1.3: Ciclo vital de pruebas unitarias descubiertas dinámicamente.</figcaption>
</figure>

<div class="break-antes"></div>
<h2 id="unit-test-exercises">Section 1.5: Ejercicios</h2>
<h3 class="exercise">Englobado Asíncrono</h3>
<p>Modificar <code>pray.js</code> para usar la versión asíncrona de <code>glob</code> en lugar de <code>glob.sync</code>.</p>
<h3 class="exercise">Cronometrando las pruebas</h3>
<p>Instalar el paquete  <a href="https://www.npmjs.com/package/microtime"><code>microtime</code></a> y luego modificar el ejemplo <code>dry-run.js</code> 
para que registre y reporte el tiempo de ejecución de las pruebas.</p>
<h3 class="exercise">Aproximadamente igual</h3>
<ol>
<li>
<p>Escribir una función <code>assertApproxEqual</code> que no haga algo si dos valores están dentro de cierta tolerancia entre sí
    pero arroja una excepción en caso contrario:</p>
<pre><code>// throws exception
assertApproxEqual(1.0, 2.0, 0.01, 'Values are too far apart')

// does not throw
assertApproxEqual(1.0, 2.0, 10.0, 'Large margin of error')
</code></pre>
</li>
<li>
<p>Modificar la función para usar una tolerancia por defecto si ninguna se especifica:</p>
<pre><code>// throws exception
assertApproxEqual(1.0, 2.0, 'Values are too far apart')

// does not throw
assertApproxEqual(1.0, 2.0, 'Large margin of error', 10.0)
</code></pre>
</li>
<li>
<p>Modificar la función  de nuevo para que revise el <a class="gl-ref" href="../glossary/#relative_error" markdown="1">error relativo</a>
    en lugar del <a class="gl-ref" href="../glossary/#absolute_error" markdown="1">error absoluto</a>.
    (el error relativo es el valor absoluto  de la diferencia entre el valor actual y el esperado,
    dividido entre el valor absoluto.)</p>
</li>
</ol>
<h3 class="exercise">Cubierta rectangular</h3>
<p>Una aplicación de ventanas representa rectángulos usando objetos con cuatro valores:
<code>x</code> e <code>y</code> son las coordenadas de la esquina inferior izquierda,
mientras que <code>w</code> y <code>h</code> son el ancho y la  altura.
Todos los valores son positivos:
la esquina inferior izquierda de la pantalla está en  <code>(0, 0)</code>
y el tamaño de la misma es  <code>WIDTH</code>x<code>HEIGHT</code>.</p>
<ol>
<li>
<p>Escribir pruebas para verificar si un si un objeto representa un rectángulo válido.</p>
</li>
<li>
<p>La función <code>overlay(a, b)</code> toma dos rectángulos y retorna o
    un nuevo rectángulo representando la región donde se superponen, o <code>null</code> si no se  superponen.
    Escribir pruebas para verificar que <code>overlay</code> funcione correctamente.</p>
</li>
<li>
<p>¿Tus  pruebas asumen que dos rectángulos se tocan en el límite de una superposición, o no?
    ¿ Qué ocurren si dos rectángulos solo coinciden un una sola esquina?</p>
</li>
</ol>
<h3 class="exercise">Seleccionando pruebas</h3>
<p>Modificar <code>pray.js</code>  para que si el usuario provee <code>-s patrón</code> o <code>--select patrón</code>,
entonces el programa solo ejecuten pruebas en archivos con la cadena <code>patrón</code> en el nombre.</p>
<h3 class="exercise">Etiquetando pruebas</h3>
<p>Modificar <code>hope.js</code>  para que usuarios puedan proveer opcionalmente un arreglo de cadenas para etiquetar tests:</p>
<div class="highlight"><pre><span></span><code><span class="nx">hope</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;Difference of 1 and 2&#39;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">assert</span><span class="p">((</span><span class="mf">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">2</span><span class="p">)</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="o">-</span><span class="mf">1</span><span class="p">),</span><span class="w"></span>
<span class="w">          </span><span class="p">[</span><span class="s1">&#39;math&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;fast&#39;</span><span class="p">])</span><span class="w"></span>
</code></pre></div>
<p>Luego, modificar <code>pray.js</code> para que que si usuarios especifican  <code>-t tagName</code> o <code>--tag tagName</code>,
solo las pruebas con esa etiqueta se ejecuten.</p>
<h3 class="exercise">Maquetar objetos</h3>
<p>Un objeto maqueta es un reemplazo simplificado  de una parte de un programa
cuyo comportamiento es más fácil de controlar y predecir que aquello que está reemplazando.
Por ejemplo,
podemos querer probar que nuestro programa haga  lo correcto   si ocurre un error mientras lee un archivo.
Para esto,
escribimos una función alrededor de  <code>fs.readFileSync</code>:</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">mockReadFileSync</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span><span class="w"> </span><span class="nx">encoding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="nx">Tagging</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">filename</span><span class="p">,</span><span class="w"> </span><span class="nx">encoding</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<p class="continue">y luego la modificamos para que arroje una excepción bajo nuestro control.
Por ejemplo,
si definimos <code>MOCK_READ_FILE_CONTROL</code> así:</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">MOCK_READ_FILE_CONTROL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">]</span><span class="w"></span>
</code></pre></div>
<p class="continue">entonces la tercera y quinta llamada a <code>mockReadFileSync</code> arrojan una excepción en vez de leer datos,
igual que toda llamada luego de la quinta.
Escribir esta función.</p>
<h3 class="exercise">Configuración y teardown</h3>
<p>Los frameworks de pruebas a menudo permiten a los programadores especificar una función <code>setup</code> 
que se ejecuta antes de cada prueba
y una función <code>teardown</code> 
que se ejecuta después de cada prueba.
(<code>setup</code> usualmente re-crea fixtures de prueba complicadas,
mientras que las funciones <code>teardown</code> a veces son necesarias para limpiar tras ejecutar pruebas,
e.g., para cerrar conexiones a la base de datos, o borrar archivos temporales.)</p>
<p>Modificar el framework de pruebas en este capítulo para que si un 
archivo de pruebas contiene algo como esto:</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">createFixtures</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="p">...</span><span class="k">do</span><span class="w"> </span><span class="nx">something</span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="nx">hope</span><span class="p">.</span><span class="nx">setup</span><span class="p">(</span><span class="nx">createFixtures</span><span class="p">)</span><span class="w"></span>
</code></pre></div>
<p class="continue">entonces la función <code>createFixtures</code> sea llamada
exactamente una vez antes de cada prueba en ese archivo.
Agregar una forma similar para registrar una función teardown con <code>hope.teardown</code>.</p>
<h3 class="exercise break-antes">Pruebas Múltiples</h3>
<p>Agregar un método <code>hope.multiTest</code> que permita a los usuarios especificar
múltiple casos de prueba para una función a la vez.
Por ejemplo, esto:</p>
<div class="highlight"><pre><span></span><code><span class="nx">hope</span><span class="p">.</span><span class="nx">multiTest</span><span class="p">(</span><span class="s1">&#39;check all of these`, functionToTest, [</span>
<span class="s1">  [[&#39;</span><span class="nx">arg1a</span><span class="s1">&#39;, &#39;</span><span class="nx">arg1b</span><span class="s1">&#39;], &#39;</span><span class="nx">result1</span><span class="s1">&#39;],</span>
<span class="s1">  [[&#39;</span><span class="nx">arg2a</span><span class="s1">&#39;, &#39;</span><span class="nx">arg2b</span><span class="s1">&#39;], &#39;</span><span class="nx">result2</span><span class="s1">&#39;],</span>
<span class="s1">  [[&#39;</span><span class="nx">arg3a</span><span class="s1">&#39;, &#39;</span><span class="nx">arg3b</span><span class="s1">&#39;], &#39;</span><span class="nx">result3</span><span class="err">&#39;</span><span class="p">]</span><span class="w"></span>
<span class="p">])</span><span class="w"></span>
</code></pre></div>
<p class="continue">debe ser equivalente a esto:</p>
<div class="highlight"><pre><span></span><code><span class="nx">hope</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;check all of these 0&#39;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">assert</span><span class="p">(</span><span class="nx">functionToTest</span><span class="p">(</span><span class="s1">&#39;arg1a&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;arg1b&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;result1&#39;</span><span class="p">)</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="nx">hope</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;check all of these 1&#39;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">assert</span><span class="p">(</span><span class="nx">functionToTest</span><span class="p">(</span><span class="s1">&#39;arg2a&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;arg2b&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;result2&#39;</span><span class="p">)</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
<span class="nx">hope</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;check all of these 2&#39;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">assert</span><span class="p">(</span><span class="nx">functionToTest</span><span class="p">(</span><span class="s1">&#39;arg3a&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;arg3b&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;result3&#39;</span><span class="p">)</span><span class="w"></span>
<span class="p">)</span><span class="w"></span>
</code></pre></div>
<h3 class="exercise">Aserciones para sets y maps</h3>
<ol>
<li>
<p>Escribir funciones <code>assertSetEqual</code> y <code>assertMapEqual</code>
    que revisen si dos instancias de <code>Set</code> o dos instancias de <code>Map</code> son iguales.</p>
</li>
<li>
<p>Escribir una función <code>assertArraySame</code>
    que verifique si dos arreglos tienen los mismos elementos,
    aún si esos están en diferente orden.</p>
</li>
</ol>
<h3 class="exercise">Probando promesas</h3>
<p>Modificar el framework de pruebas unitarias  para manejar  funciones <code>async</code>,
para  que:</p>
<div class="highlight"><pre><span></span><code><span class="nx">hope</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="s1">&#39;delayed test&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{...})</span><span class="w"></span>
</code></pre></div>
<p class="continue">haga lo correcto.
(Nótese que pueden usar <code>typeof</code> para determinar si un objeto dado a <code>hope.test</code>
es una función o una promesa.)</p>
        </main>
      </div>
    </div>
  </body>
</html>
