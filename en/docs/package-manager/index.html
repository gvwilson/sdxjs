<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  <script defer data-domain="third-bit.com" src="https://plausible.io/js/plausible.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script defer src="../mccole.js"></script>
  <title>Software Design by Example: Package Manager</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  <a href="../">Software Design by Example</a>
<br/><em><a href="https://www.taylorfrancis.com/books/mono/10.1201/9781003317807/software-design-example-greg-wilson" alt="buy the book">buy the book</a></em>
</p>
<ol class="toc-chapter">
  
  <li>
    <a href="../introduction/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../systems-programming/">
      Systems Programming
    </a>
  </li>
  
  <li>
    <a href="../async-programming/">
      Asynchronous Programming
    </a>
  </li>
  
  <li>
    <a href="../unit-test/">
      Unit Testing
    </a>
  </li>
  
  <li>
    <a href="../file-backup/">
      File Backup
    </a>
  </li>
  
  <li>
    <a href="../data-table/">
      Data Tables
    </a>
  </li>
  
  <li>
    <a href="../pattern-matching/">
      Pattern Matching
    </a>
  </li>
  
  <li>
    <a href="../regex-parser/">
      Parsing Expressions
    </a>
  </li>
  
  <li>
    <a href="../page-templates/">
      Page Templates
    </a>
  </li>
  
  <li>
    <a href="../build-manager/">
      Build Manager
    </a>
  </li>
  
  <li>
    <a href="../layout-engine/">
      Layout Engine
    </a>
  </li>
  
  <li>
    <a href="../file-interpolator/">
      File Interpolator
    </a>
  </li>
  
  <li>
    <a href="../module-loader/">
      Module Loader
    </a>
  </li>
  
  <li>
    <a href="../style-checker/">
      Style Checker
    </a>
  </li>
  
  <li>
    <a href="../code-generator/">
      Code Generator
    </a>
  </li>
  
  <li>
    <a href="../doc-generator/">
      Documentation Generator
    </a>
  </li>
  
  <li>
    <a href="../module-bundler/">
      Module Bundler
    </a>
  </li>
  
  <li>
    <a href="../package-manager/">
      <strong>Package Manager</strong>
    </a>
  </li>
  
  <li>
    <a href="../virtual-machine/">
      Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      Debugger
    </a>
  </li>
  
  <li>
    <a href="../conclusion/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contributing/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../bibliography/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

<p><em><a href="../sdxjs-examples.zip" alt="source code archive">download examples</a></em></p>


      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 18: Package Manager</h1>


          
            

            
<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#backward_compatible" markdown="1">backward-compatible</a>, <a class="gl-ref" href="../glossary/#combinatorial_explosion" markdown="1">combinatorial explosion</a>, <a class="gl-ref" href="../glossary/#heuristic" markdown="1">heuristic</a>, <a class="gl-ref" href="../glossary/#manifest" markdown="1">manifest</a>, <a class="gl-ref" href="../glossary/#patch" markdown="1">patch</a>, <a class="gl-ref" href="../glossary/#prune" markdown="1">prune</a>, <a class="gl-ref" href="../glossary/#sat_solver" markdown="1">SAT solver</a>, <a class="gl-ref" href="../glossary/#scoring_function" markdown="1">scoring function</a>, <a class="gl-ref" href="../glossary/#seed" markdown="1">seed</a>, <a class="gl-ref" href="../glossary/#semantic_versioning" markdown="1">semantic versioning</a>
</p>


            <div class="page-toc"></div>
            <p>There is no point building software if you can&rsquo;t install it.
Inspired by the <span class="ix-entry" ix-key="Comprehensive TeX Archive Network" markdown="1">Comprehensive TeX Archive Network</span> <a href="https://www.ctan.org/">CTAN</a>,
most languages now have an online archive from which developers can download packages.
Each package typically has a name and one or more version(s);
each version may have a list of dependencies,
and the package may specify a version or range of versions for each dependency.</p>
<p>Downloading files requires some web programming that is out of scope for this book,
while installing those files in the right places
uses the systems programming skills of <a class="x-ref" href="../systems-programming/">Chapter 2</a>.
The piece we are missing is a way to figure out exactly what versions of different packages to install
in order to create a consistent setup.
If packages A and B require different versions of C,
it might not be possible to use A and B together.
On the other hand,
if each one requires a range of versions of C and those ranges overlap,
we might be able to find a combination that works&mdash;at least,
until we try to install packages D and E.</p>
<p>We <em>could</em> install every package&rsquo;s dependencies separately with it;
the disk space wouldn&rsquo;t be much of an obstacle,
but loading dozens of copies of the same package into the browser
would slow applications down.
This chapter therefore explores how to find a workable installation or prove that there isn&rsquo;t one.
It is based in part on <a href="https://classic.yarnpkg.com/blog/2017/07/11/lets-dev-a-package-manager/">this tutorial</a> by <span class="ix-entry" ix-key="Nison, Maël" markdown="1"><a href="https://arcanis.github.io/">Maël Nison</a></span>.</p>
<div class="callout">
<h3>Satisfiability</h3>
<p>What we are trying to do is find a version for each package
that makes the assertion &ldquo;P is compatible with all its dependencies&rdquo; true
for every package P.
The general-purpose tools for doing this are called <span class="ix-entry" ix-key="satisfiability;SAT solver" markdown="1"><a class="gl-ref" href="../glossary/#sat_solver" markdown="1">SAT solvers</a></span>
because they determine whether there is some assignment of values
that satisfies the claim (i.e., makes it true).
Finding a solution can be extremely hard in the general case,
so most SAT solvers use heuristics to try to reduce the work.</p>
</div>
<h2 id="package-manager-semver">Section 18.2: What is semantic versioning?</h2>
<p>Most software projects use <span class="ix-entry" ix-key="semantic versioning" markdown="1"><a class="gl-ref" href="../glossary/#semantic_versioning" markdown="1">semantic versioning</a></span> for software releases.
Each version number consists of three integers X.Y.Z,
where X is the major version,
Y is the minor version,
and Z is the <span class="ix-entry" ix-key="patch number;semantic versioning!patch number" markdown="1"><a class="gl-ref" href="../glossary/#patch" markdown="1">patch</a></span> number.
(The <a href="https://semver.org/">full specification</a> allows for more fields,
but we will ignore them in this tutorial.)</p>
<div class="pagebreak"></div>

<p>A package&rsquo;s authors increment its major version number
every time something changes in a way that makes the package incompatible with previous versions.
For example,
if they add a required parameter to a function,
then code built for the old version will fail or behave unpredictably with the new one.
The minor version number is incremented when new functionality
is <span class="ix-entry" ix-key="backward compatibility" markdown="1"><a class="gl-ref" href="../glossary/#backward_compatible" markdown="1">backward-compatible</a></span>&mdash;i.e.,
it won&rsquo;t break any existing code&mdash;and the patch number is changed
for backward-compatible bug fixes that don&rsquo;t add any new features.</p>
<p>The notation for specifying a project&rsquo;s dependencies looks a lot like arithmetic:
<code>&gt;= 1.2.3</code> means &ldquo;any version from 1.2.3 onward&rdquo;,
<code>&lt; 4</code> means &ldquo;any version before 4.anything&rdquo;,
and <code>1.0 - 3.1</code> means &ldquo;any version in the specified range (including patches)&rdquo;.
Note that version 2.1 is greater than version 1.99:
no matter how large a minor version number becomes,
it never spills over into the major version number
in the way that minutes add up to hours or months add up to years.</p>
<p>It isn&rsquo;t hard to write a few simple comparisons for semantic version identifiers,
but getting all the different cases right is almost as tricky as handling dates and times correctly,
so we will rely on the <a href="https://www.npmjs.com/package/semver"><code>semver</code></a> module.
<code>semver.valid('1.2.3')</code> checks that <code>1.2.3</code> is a valid version identifier,
while <code>semver.satisfies('2.2', '1.0 - 3.1')</code> checks that its first argument
is compatible with the range specified in its second.</p>
<h2 id="package-manager-consistent">Section 18.3: How can we find a consistent set of packages?</h2>
<p>Imagine that each package we need is represented as an axis on a multi-dimensional grid,
with its versions as the tick marks
(<a class="fig-ref" href="../package-manager/#package-manager-allowable">Figure 18.1</a>).
Each point on the grid is a possible combination of package versions.
We can block out regions of this grid using the constraints on the package versions;
whatever points are left when we&rsquo;re done represent legal combinations.</p>
<figure id="package-manager-allowable">
  <img src="./allowable.svg" alt="Allowable versions"/>
  <figcaption markdown="1">Figure 18.1: Finding allowable combinations of package versions.</figcaption>
</figure>

<p>For example,
suppose we have the set of requirements shown in <a class="tbl-ref" href="../package-manager/#package-manager-example-dependencies">Table 18.1</a>.
There are 18 possible configurations
(2 for X × 3 for Y × 3 for Z)
but 16 are excluded by various incompatibilities.
Of the two remaining possibilities,
X/2 + Y/3 + Z/3 is strictly greater than X/2 + Y/2 + Z/2,
so we would probably choose the former
(<a class="tbl-ref" href="../package-manager/#package-manager-example-result">Table 18.2</a>).
If we wound up with A/1 + B/2 versus A/2 + B/1,
we would need to add rules for resolving ties.</p>
<div class="callout">
<h3>Reproducibility</h3>
<p>No matter what kind of software you build,
a given set of inputs should always produce the same output;
if they don&rsquo;t,
testing is much more difficult (or impossible) <span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Taschuk2017">Taschuk2017</a>]</span>.
There may not be a strong reason to prefer one mutually-compatible set of packages over another,
but a package manager should still resolve the ambiguity the same way every time.
It may not be what everyone wants,
but at least they will be unhappy for the same reasons everywhere.
This is why NPM has both <code>package.json</code> and a <code>package-lock.json</code> files:
the former is written by the user and specifies what they <em>want</em>,
while the latter is created by the package manager and specifies exactly what they <em>got</em>.
If you want to reproduce someone else&rsquo;s setup for debugging purposes,
you should install what is described in the latter file.</p>
</div>
<div class="table"><table id="package-manager-example-dependencies" class="table-here"><caption>Table 18.1: Example package dependencies.</caption>
<thead>
<tr>
<th>Package</th>
<th>Requires</th>
</tr>
</thead>
<tbody>
<tr>
<td>X/1</td>
<td>Y/1-2</td>
</tr>
<tr>
<td>X/1</td>
<td>Z/1</td>
</tr>
<tr>
<td>X/2</td>
<td>Y/2-3</td>
</tr>
<tr>
<td>X/2</td>
<td>Z/1-2</td>
</tr>
<tr>
<td>Y/1</td>
<td>Z/2</td>
</tr>
<tr>
<td>Y/2</td>
<td>Z/2-3</td>
</tr>
<tr>
<td>Y/3</td>
<td>Z/3</td>
</tr>
<tr>
<td>Z/1</td>
<td></td>
</tr>
<tr>
<td>Z/2</td>
<td></td>
</tr>
<tr>
<td>Z/3</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<div class="table"><table id="package-manager-example-result" class="table-here"><caption>Table 18.2: Result for example package dependencies.</caption>
<thead>
<tr>
<th>X</th>
<th>Y</th>
<th>Z</th>
<th>Excluded</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>Y/1 - Z/1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>2</td>
<td>X/1 - Z/2</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>3</td>
<td>X/1 - Z/3</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>1</td>
<td>Y/2 - Z/1</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>2</td>
<td>X/1 - Z/2</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>X/1 - Z/3</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>1</td>
<td>X/1 - Y/3</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>2</td>
<td>X/1 - Y/3</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>3</td>
<td>X/1 - Y/3</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
<td>X/2 - Y/1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>2</td>
<td>X/2 - Y/1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>3</td>
<td>X/2 - Y/1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>1</td>
<td>Y/2 - Z/1</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>3</td>
<td>X/2 - Z/3</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>1</td>
<td>Y/3 - Z/1</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>2</td>
<td>Y/3 - Z/2</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>3</td>
<td>X/2 - Z/3</td>
</tr>
</tbody>
</table>
</div>
<p>To construct <a class="tbl-ref" href="../package-manager/#package-manager-example-dependencies">Table 18.1</a>
we find the <span class="ix-entry" ix-key="transitive closure" markdown="1">transitive closure</span> of all packages plus all of their dependencies.
We then pick two packages and create a list of their valid pairs.
Choosing a third package,
we cross off pairs that can&rsquo;t be satisfied
to leave triples of legal combinations.
We repeat this until all packages are included in our table.</p>
<p>In the worst case this procedure will create
a <span class="ix-entry" ix-key="combinatorial explosion" markdown="1"><a class="gl-ref" href="../glossary/#combinatorial_explosion" markdown="1">combinatorial explosion</a></span> of possibilities.
Smart algorithms will try to add packages to the mix
in an order that minimize the number of new possibilities at each stage,
or create pairs and then combine them to create pairs of pairs and so on.
Our algorithm will be simpler (and therefore slower),
but illustrates the key idea.</p>
<h2 id="package-manager-constraints">Section 18.4: How can we satisfy constraints?</h2>
<p>To avoid messing around with parsers,
our programs reads a JSON data structure describing the problem;
a real package manager would read the <span class="ix-entry" ix-key="manifest (of package);package manifest" markdown="1"><a class="gl-ref" href="../glossary/#manifest" markdown="1">manifests</a></span> of the packages in question
and construct a similar data structure.
We will stick to single-digit version numbers for readability,
and will use this as our first test case:</p>
<div class="code-sample lang-json" title="double-chained.json">
<div class="highlight"><pre><span></span><code><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;X&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nt">&quot;1&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;Y&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;1&quot;</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">},</span><span class="w"></span>
<span class="w">    </span><span class="nt">&quot;2&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nt">&quot;Y&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;2&quot;</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="nt">&quot;Y&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nt">&quot;1&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{},</span><span class="w"></span>
<span class="w">    </span><span class="nt">&quot;2&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</div>
<div class="callout">
<h3>Comments</h3>
<p>If you ever design a data format,
please include a standard way for people to add comments,
because they will always want to.
YAML has this,
but JSON and CSV don&rsquo;t.</p>
</div>
<p>To check if a combination of specific versions of packages is compatible with a manifest,
we add each package to our active list in turn and look for violations.
If there aren&rsquo;t any more packages to add and we haven&rsquo;t found a violation,
then what we have must be a legal configuration.</p>
<div class="code-sample lang-js" title="sweep.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">configStr</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./config-str.js&#39;</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">sweep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">manifest</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">manifest</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"></span>
<span class="w">  </span><span class="nx">recurse</span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">names</span><span class="p">,</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">recurse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">names</span><span class="p">,</span><span class="w"> </span><span class="nx">config</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">names</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">allows</span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">config</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="p">...</span><span class="nx">config</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">names</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">rest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">names</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">version</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">manifest</span><span class="p">[</span><span class="nx">next</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">config</span><span class="p">[</span><span class="nx">next</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">version</span><span class="w"></span>
<span class="w">      </span><span class="nx">recurse</span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">rest</span><span class="p">,</span><span class="w"> </span><span class="nx">config</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">sweep</span><span class="w"></span>
</code></pre></div>
</div>
<p>The simplest way to find configurations is to sweep over all possibilities.
For debugging purposes,
our function prints possibilities as it goes:</p>
<div class="code-sample lang-js" title="sweep.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">allows</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">config</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">leftN</span><span class="p">,</span><span class="w"> </span><span class="nx">leftV</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">config</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">requirements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">manifest</span><span class="p">[</span><span class="nx">leftN</span><span class="p">][</span><span class="nx">leftV</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">rightN</span><span class="p">,</span><span class="w"> </span><span class="nx">rightVAll</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">requirements</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">rightVAll</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">config</span><span class="p">[</span><span class="nx">rightN</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">configStr</span><span class="p">(</span><span class="nx">config</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="kd">const</span><span class="w"> </span><span class="nx">missing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">config</span><span class="p">[</span><span class="nx">rightN</span><span class="p">]</span><span class="w"></span>
<span class="w">        </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">title</span><span class="si">}</span><span class="sb"> @ </span><span class="si">${</span><span class="nx">leftN</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">leftV</span><span class="si">}</span><span class="sb"> </span><span class="si">${</span><span class="nx">rightN</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">missing</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">configStr</span><span class="p">(</span><span class="nx">config</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</div>
<p>If we run this program on the two-package example shown earlier, we get this output:</p>
<div class="code-sample lang-sh" title="sweep-double-chained.sh">
<div class="highlight"><pre><span></span><code>node driver.js ./sweep.js double-chained.json
</code></pre></div>
</div>
<div class="code-sample lang-out" title="sweep-double-chained.out">
<div class="highlight"><pre><span></span><code>{X:1 Y:1}
{X:1 Y:2} @ X/1 Y/2
{X:2 Y:1} @ X/2 Y/1
{X:2 Y:2}
</code></pre></div>
</div>
<p>When we run it on our triple-package example, we get this:</p>
<div class="code-sample lang-sh" title="sweep-triple.sh">
<div class="highlight"><pre><span></span><code>node driver.js ./sweep.js triple.json
</code></pre></div>
</div>
<div class="code-sample lang-out" title="sweep-triple.out">
<div class="highlight"><pre><span></span><code>{X:1 Y:1 Z:1} @ Y/1 Z/1
{X:1 Y:1 Z:2} @ X/1 Z/2
{X:1 Y:1 Z:3} @ X/1 Z/3
{X:1 Y:2 Z:1} @ Y/2 Z/1
{X:1 Y:2 Z:2} @ X/1 Z/2
{X:1 Y:2 Z:3} @ X/1 Z/3
{X:1 Y:3 Z:1} @ X/1 Y/3
{X:1 Y:3 Z:2} @ X/1 Y/3
{X:1 Y:3 Z:3} @ X/1 Y/3
{X:2 Y:1 Z:1} @ X/2 Y/1
{X:2 Y:1 Z:2} @ X/2 Y/1
{X:2 Y:1 Z:3} @ X/2 Y/1
{X:2 Y:2 Z:1} @ Y/2 Z/1
{X:2 Y:2 Z:2}
{X:2 Y:2 Z:3} @ X/2 Z/3
{X:2 Y:3 Z:1} @ Y/3 Z/1
{X:2 Y:3 Z:2} @ Y/3 Z/2
{X:2 Y:3 Z:3} @ X/2 Z/3
</code></pre></div>
</div>
<p>This works,
but it is doing a lot of unnecessary work.
If we sort the output by the case that caught the exclusion,
it turns out that 9 of the 17 exclusions are redundant rediscovery of a previously known problem
(<a class="tbl-ref" href="../package-manager/#package-manager-exclusions">Table 18.3</a>).</p>
<div class="table"><table id="package-manager-exclusions" class="table-here"><caption>Table 18.3: Package exclusions.</caption>
<thead>
<tr>
<th>Excluded</th>
<th>X</th>
<th>Y</th>
<th>Z</th>
</tr>
</thead>
<tbody>
<tr>
<td>X/1 - Y/3</td>
<td>1</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td>1</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>…</td>
<td>1</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>X/1 - Z/2</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>…</td>
<td>1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td>X/1 - Z/3</td>
<td>1</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>…</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>X/2 - Y/1</td>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td>2</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>…</td>
<td>2</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>X/2 - Z/3</td>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>…</td>
<td>2</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>Y/1 - Z/1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>Y/2 - Z/1</td>
<td>1</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td>2</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>Y/3 - Z/1</td>
<td>2</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>…</td>
<td>2</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td>2</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<h2 id="package-manager-optimize">Section 18.5: How can we do less work?</h2>
<p>We can make this more efficient by <span class="ix-entry" ix-key="prune (a search tree)" markdown="1"><a class="gl-ref" href="../glossary/#prune" markdown="1">pruning</a></span> the search tree
as we go along
(<a class="fig-ref" href="../package-manager/#package-manager-pruning">Figure 18.2</a>).
After all,
if we know that X and Y are incompatible,
there is no need to check Z as well.</p>
<figure id="package-manager-pruning">
  <img src="./pruning.svg" alt="Pruning the search tree"/>
  <figcaption markdown="1">Figure 18.2: Pruning options in the search tree to reduce work.</figcaption>
</figure>

<p>This version of the program collects possible solutions and displays them at the end.
It only keeps checking a partial solution if what it has found so far looks good:</p>
<div class="code-sample lang-js" title="prune.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">configStr</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./config-str.js&#39;</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">prune</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">manifest</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">manifest</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"></span>
<span class="w">  </span><span class="nx">recurse</span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">names</span><span class="p">,</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">config</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">configStr</span><span class="p">(</span><span class="nx">config</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">recurse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">names</span><span class="p">,</span><span class="w"> </span><span class="nx">config</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">names</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="p">...</span><span class="nx">config</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">names</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">rest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">names</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">version</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">manifest</span><span class="p">[</span><span class="nx">next</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">config</span><span class="p">[</span><span class="nx">next</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">version</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">compatible</span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">config</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">recurse</span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">rest</span><span class="p">,</span><span class="w"> </span><span class="nx">config</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="ow">delete</span><span class="w"> </span><span class="nx">config</span><span class="p">[</span><span class="nx">next</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="kd">const</span><span class="w"> </span><span class="nx">report</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">config</span><span class="p">,</span><span class="w"> </span><span class="nx">leftN</span><span class="p">,</span><span class="w"> </span><span class="nx">leftV</span><span class="p">,</span><span class="w"> </span><span class="nx">rightN</span><span class="p">,</span><span class="w"> </span><span class="nx">rightV</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">configStr</span><span class="p">(</span><span class="nx">config</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">title</span><span class="si">}</span><span class="sb"> @ </span><span class="si">${</span><span class="nx">leftN</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">leftV</span><span class="si">}</span><span class="sb"> </span><span class="si">${</span><span class="nx">rightN</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">rightV</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">prune</span><span class="w"></span>
</code></pre></div>
</div>
<p>The <code>compatible</code> function checks to see if adding something will leave us with a consistent configuration:</p>
<div class="code-sample lang-js" title="prune.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">config</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">leftN</span><span class="p">,</span><span class="w"> </span><span class="nx">leftV</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">config</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">leftR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">manifest</span><span class="p">[</span><span class="nx">leftN</span><span class="p">][</span><span class="nx">leftV</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">rightN</span><span class="p">,</span><span class="w"> </span><span class="nx">rightV</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">config</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nx">rightN</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">leftR</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">leftR</span><span class="p">[</span><span class="nx">rightN</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="nx">rightV</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">report</span><span class="p">(</span><span class="nx">config</span><span class="p">,</span><span class="w"> </span><span class="nx">leftN</span><span class="p">,</span><span class="w"> </span><span class="nx">leftV</span><span class="p">,</span><span class="w"> </span><span class="nx">rightN</span><span class="p">,</span><span class="w"> </span><span class="nx">rightV</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">rightR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">manifest</span><span class="p">[</span><span class="nx">rightN</span><span class="p">][</span><span class="nx">rightV</span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nx">leftN</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">rightR</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">rightR</span><span class="p">[</span><span class="nx">leftN</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="nx">leftV</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">report</span><span class="p">(</span><span class="nx">config</span><span class="p">,</span><span class="w"> </span><span class="nx">leftN</span><span class="p">,</span><span class="w"> </span><span class="nx">leftV</span><span class="p">,</span><span class="w"> </span><span class="nx">rightN</span><span class="p">,</span><span class="w"> </span><span class="nx">rightV</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</div>
<p>Checking as we go gets us from 18 complete solutions to 11.
One is workable
and two are incomplete&mdash;they represent 6 possible complete solutions that we didn&rsquo;t need to finish:</p>
<div class="code-sample lang-out" title="prune-triple.out">
<div class="highlight"><pre><span></span><code>{X:1 Y:1 Z:1} @ Y/1 Z/1
{X:1 Y:1 Z:2} @ X/1 Z/2
{X:1 Y:1 Z:3} @ X/1 Z/3
{X:1 Y:2 Z:1} @ Y/2 Z/1
{X:1 Y:2 Z:2} @ X/1 Z/2
{X:1 Y:2 Z:3} @ X/1 Z/3
{X:1 Y:3} @ X/1 Y/3
{X:2 Y:1} @ X/2 Y/1
{X:2 Y:2 Z:1} @ Y/2 Z/1
{X:2 Y:2 Z:3} @ X/2 Z/3
{X:2 Y:3 Z:1} @ Y/3 Z/1
{X:2 Y:3 Z:2} @ Y/3 Z/2
{X:2 Y:3 Z:3} @ X/2 Z/3
{X:2 Y:2 Z:2}
</code></pre></div>
</div>
<p>Another way to look at the work is the number of steps in the search.
The full search had 18×3 = 54 steps.
Pruning leaves us with (12×3) + (2×2) = 40 steps
so we have eliminated roughly 1/4 of the work.</p>
<p>What if we searched in the reverse order?</p>
<div class="code-sample lang-js" title="reverse.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">configStr</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./config-str.js&#39;</span><span class="w"></span>

<span class="c1">// [reverse]</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">reverse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">manifest</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">names</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">manifest</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">names</span><span class="p">.</span><span class="nx">reverse</span><span class="p">()</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"></span>
<span class="w">  </span><span class="nx">recurse</span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">names</span><span class="p">,</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">config</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">configStr</span><span class="p">(</span><span class="nx">config</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// [/reverse]</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">recurse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">names</span><span class="p">,</span><span class="w"> </span><span class="nx">config</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">names</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="p">...</span><span class="nx">config</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">names</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">rest</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">names</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mf">1</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="nx">version</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">manifest</span><span class="p">[</span><span class="nx">next</span><span class="p">])</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">config</span><span class="p">[</span><span class="nx">next</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">version</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">compatible</span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">config</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">recurse</span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">rest</span><span class="p">,</span><span class="w"> </span><span class="nx">config</span><span class="p">,</span><span class="w"> </span><span class="nx">result</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="ow">delete</span><span class="w"> </span><span class="nx">config</span><span class="p">[</span><span class="nx">next</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">manifest</span><span class="p">,</span><span class="w"> </span><span class="nx">config</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">leftN</span><span class="p">,</span><span class="w"> </span><span class="nx">leftV</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">config</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">leftR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">manifest</span><span class="p">[</span><span class="nx">leftN</span><span class="p">][</span><span class="nx">leftV</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">const</span><span class="w"> </span><span class="p">[</span><span class="nx">rightN</span><span class="p">,</span><span class="w"> </span><span class="nx">rightV</span><span class="p">]</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="nb">Object</span><span class="p">.</span><span class="nx">entries</span><span class="p">(</span><span class="nx">config</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nx">rightN</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">leftR</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">leftR</span><span class="p">[</span><span class="nx">rightN</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="nx">rightV</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">report</span><span class="p">(</span><span class="nx">config</span><span class="p">,</span><span class="w"> </span><span class="nx">leftN</span><span class="p">,</span><span class="w"> </span><span class="nx">leftV</span><span class="p">,</span><span class="w"> </span><span class="nx">rightN</span><span class="p">,</span><span class="w"> </span><span class="nx">rightV</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="kd">const</span><span class="w"> </span><span class="nx">rightR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">manifest</span><span class="p">[</span><span class="nx">rightN</span><span class="p">][</span><span class="nx">rightV</span><span class="p">]</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nx">leftN</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">rightR</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">rightR</span><span class="p">[</span><span class="nx">leftN</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="nx">leftV</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">report</span><span class="p">(</span><span class="nx">config</span><span class="p">,</span><span class="w"> </span><span class="nx">leftN</span><span class="p">,</span><span class="w"> </span><span class="nx">leftV</span><span class="p">,</span><span class="w"> </span><span class="nx">rightN</span><span class="p">,</span><span class="w"> </span><span class="nx">rightV</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kc">false</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="kc">true</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">report</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">config</span><span class="p">,</span><span class="w"> </span><span class="nx">leftN</span><span class="p">,</span><span class="w"> </span><span class="nx">leftV</span><span class="p">,</span><span class="w"> </span><span class="nx">rightN</span><span class="p">,</span><span class="w"> </span><span class="nx">rightV</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">title</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">configStr</span><span class="p">(</span><span class="nx">config</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`</span><span class="si">${</span><span class="nx">title</span><span class="si">}</span><span class="sb"> @ </span><span class="si">${</span><span class="nx">leftN</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">leftV</span><span class="si">}</span><span class="sb"> </span><span class="si">${</span><span class="nx">rightN</span><span class="si">}</span><span class="sb">/</span><span class="si">${</span><span class="nx">rightV</span><span class="si">}</span><span class="sb">`</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">reverse</span><span class="w"></span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="reverse-triple.out">
<div class="highlight"><pre><span></span><code>{Z:1 Y:1} @ Z/1 Y/1
{Z:1 Y:2} @ Z/1 Y/2
{Z:1 Y:3} @ Z/1 Y/3
{Z:2 Y:1 X:1} @ Z/2 X/1
{Z:2 Y:1 X:2} @ Y/1 X/2
{Z:2 Y:2 X:1} @ Z/2 X/1
{Z:2 Y:3} @ Z/2 Y/3
{Z:3 Y:1} @ Z/3 Y/1
{Z:3 Y:2 X:1} @ Z/3 X/1
{Z:3 Y:2 X:2} @ Z/3 X/2
{Z:3 Y:3 X:1} @ Z/3 X/1
{Z:3 Y:3 X:2} @ Z/3 X/2
{Z:2 Y:2 X:2}
</code></pre></div>
</div>
<p>Now we have (8×3) + (5×2) = 34 steps,
i.e.,
we have eliminated roughly 1/3 of the work.
That may not seem like a big difference,
but if we go five levels deep at the same rate,
it cuts the work in half.
There are lots of <a class="gl-ref" href="../glossary/#heuristic" markdown="1">heuristics</a> for searching trees;
none are guaranteed to give better performance in every case,
but most give better performance in most cases.</p>
<div class="callout">
<h3>What research is for</h3>
<p><span class="ix-entry" ix-key="SAT solver" markdown="1">SAT solvers</span> are like regular expression libraries and random number generators:
it is the work of many lifetimes to create ones that are both fast and correct.
A lot of computer science researchers devote their careers to highly-specialized topics like this.
The debates often seem esoteric to outsiders,
and most ideas turn out to be dead ends,
but even small improvements in fundamental tools can have a profound impact.</p>
</div>
<h2 id="package-manager-exercises">Section 18.6: Exercises</h2>
<h3 class="exercise">Comparing semantic versions</h3>
<p>Write a function that takes an array of semantic version specifiers
and sorts them in ascending order.
Remember that <code>2.1</code> is greater than <code>1.99</code>.</p>
<h3 class="exercise">Parsing semantic versions</h3>
<p>Using the techniques of <a class="x-ref" href="../regex-parser/">Chapter 8</a>,
write a parser for a subset of the <a href="https://semver.org/">semantic versioning specification</a>.</p>
<h3 class="exercise">Using scoring functions</h3>
<p>Many different combinations of package versions can be mutually compatible.
One way to decide which actual combination to install
is to create a <a class="gl-ref" href="../glossary/#scoring_function" markdown="1">scoring function</a>
that measures how good or bad a particular combination is.
For example,
a function could measure the &ldquo;distance&rdquo; between two versions as:</p>
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">score</span><span class="w"> </span><span class="p">(</span><span class="nx">X</span><span class="p">,</span><span class="w"> </span><span class="nx">Y</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">X</span><span class="p">.</span><span class="nx">major</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="nx">Y</span><span class="p">.</span><span class="nx">major</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mf">100</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">abs</span><span class="p">(</span><span class="nx">X</span><span class="p">.</span><span class="nx">major</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">Y</span><span class="p">.</span><span class="nx">major</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">X</span><span class="p">.</span><span class="nx">minor</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="nx">Y</span><span class="p">.</span><span class="nx">minor</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mf">10</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">abs</span><span class="p">(</span><span class="nx">X</span><span class="p">.</span><span class="nx">minor</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">Y</span><span class="p">.</span><span class="nx">minor</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">abs</span><span class="p">(</span><span class="nx">X</span><span class="p">.</span><span class="nx">patch</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">Y</span><span class="p">.</span><span class="nx">patch</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
<ol>
<li>
<p>Implement a working version of this function
    and use it to measure the total distance between
    the set of packages found by the solver
    and the set containing the most recent version of each package.</p>
</li>
<li>
<p>Explain why this doesn&rsquo;t actually solve the original problem.</p>
</li>
</ol>
<h3 class="exercise">Using full semantic versions</h3>
<p>Modify the constraint solver to use full semantic versions instead of single digits.</p>
<h3 class="exercise">Regular releases</h3>
<p>Some packages release new versions on a regular cycle,
e.g.,
Version 2021.1 is released on March 1 of 2021,
Version 2021.2 is released on September 1 of that year,
version 2022.1 is released on March 1 of the following year,
and so on.</p>
<ol>
<li>
<p>How does this make package management easier?</p>
</li>
<li>
<p>How does it make it more difficult?</p>
</li>
</ol>
<h3 class="exercise">Writing unit tests</h3>
<p>Write unit tests for the constraint solver using Mocha.</p>
<h3 class="exercise">Generating test fixtures</h3>
<p>Write a function that creates fixtures for testing the constraint solver:</p>
<ol>
<li>
<p>Its first argument is an object whose keys are (fake) package names
    and whose values are integers indicating the number of versions of that package
    to include in the test set,
    such as <code>{'left': 3, 'middle': 2, 'right': 15}</code>.
    Its second argument is a <a class="gl-ref" href="../glossary/#seed" markdown="1">seed</a> for random number generation.</p>
</li>
<li>
<p>It generates one valid configuration,
    such as <code>{'left': 2, 'middle': 2, 'right': 9}</code>.
    (This is to ensure that there is at least one installable set of packages.)</p>
</li>
<li>
<p>It then generates random constraints between the packages.
    (These may or may not result in other installable combinations.)
    When this is done,
    it adds constraints so that the valid configuration from the previous step is included.</p>
</li>
</ol>
<h3 class="exercise">Searching least first</h3>
<p>Rewrite the constraint solver so that it searches packages
by looking at those with the fewest available versions first.
Does this reduce the amount of work done for the small examples in this chapter?
Does it reduce the amount of work done for larger examples?</p>
<h3 class="exercise">Using generators</h3>
<p>Rewrite the constraint solver to use generators.</p>
<h3 class="exercise">Using exclusions</h3>
<ol>
<li>
<p>Modify the constraint solver so that
    it uses a list of package exclusions instead of a list of package requirements,
    i.e.,
    its input tells it that version 1.2 of package Red
    can <em>not</em> work with versions 3.1 and 3.2 of package Green
    (which implies that Red 1.2 can work with any other versions of Green).</p>
</li>
<li>
<p>Explain why package managers aren&rsquo;t built this way.</p>
</li>
</ol>
          
        </main>
      </div>
    </div>
  </body>
</html>
