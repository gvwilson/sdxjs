<!DOCTYPE html>
<html lang="en">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  <link rel="stylesheet" href="../mccole.css">
  <link rel="stylesheet" href="../tango.css">
  
  <script>
    MathJax = {
      tex: {
        inlineMath: [['\\(', '\\)']]
      }
    };
  </script>
  <script
    type="text/javascript"
    id="MathJax-script"
    async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <title>Software Design by Example: Parsing Expressions</title>
</head>

  <body>
    <div class="row">
      <div class="sidebar">
        <p>
  <img src="../logo.svg" alt="site logo" class="logo" />
  <a href="../">Software Design by Example</a>
</p>
<ol class="toc-chapter">
  
  <li>
    <a href="../introduction/">
      Introduction
    </a>
  </li>
  
  <li>
    <a href="../systems-programming/">
      Systems Programming
    </a>
  </li>
  
  <li>
    <a href="../async-programming/">
      Asynchronous Programming
    </a>
  </li>
  
  <li>
    <a href="../unit-test/">
      Unit Testing
    </a>
  </li>
  
  <li>
    <a href="../file-backup/">
      File Backup
    </a>
  </li>
  
  <li>
    <a href="../data-table/">
      Data Tables
    </a>
  </li>
  
  <li>
    <a href="../pattern-matching/">
      Pattern Matching
    </a>
  </li>
  
  <li>
    <a href="../regex-parser/">
      <strong>Parsing Expressions</strong>
    </a>
  </li>
  
  <li>
    <a href="../page-templates/">
      Page Templates
    </a>
  </li>
  
  <li>
    <a href="../build-manager/">
      Build Manager
    </a>
  </li>
  
  <li>
    <a href="../layout-engine/">
      Layout Engine
    </a>
  </li>
  
  <li>
    <a href="../file-interpolator/">
      File Interpolator
    </a>
  </li>
  
  <li>
    <a href="../module-loader/">
      Module Loader
    </a>
  </li>
  
  <li>
    <a href="../style-checker/">
      Style Checker
    </a>
  </li>
  
  <li>
    <a href="../code-generator/">
      Code Generator
    </a>
  </li>
  
  <li>
    <a href="../doc-generator/">
      Documentation Generator
    </a>
  </li>
  
  <li>
    <a href="../module-bundler/">
      Module Bundler
    </a>
  </li>
  
  <li>
    <a href="../package-manager/">
      Package Manager
    </a>
  </li>
  
  <li>
    <a href="../virtual-machine/">
      Virtual Machine
    </a>
  </li>
  
  <li>
    <a href="../debugger/">
      Debugger
    </a>
  </li>
  
  <li>
    <a href="../conclusion/">
      Conclusion
    </a>
  </li>
  
</ol>
<ol class="toc-appendix">
  
  <li>
    <a href="../license/">
      License
    </a>
  </li>
  
  <li>
    <a href="../conduct/">
      Code of Conduct
    </a>
  </li>
  
  <li>
    <a href="../contributing/">
      Contributing
    </a>
  </li>
  
  <li>
    <a href="../bibliography/">
      Bibliography
    </a>
  </li>
  
  <li>
    <a href="../glossary/">
      Glossary
    </a>
  </li>
  
  <li>
    <a href="../contents/">
      Index
    </a>
  </li>
  
</ol>

      </div>
      <div id="printable" class="contents bordered">
        <main>
          
  <h1>Chapter 8: Parsing Expressions</h1>


          

          
<p class="definitions">
  Terms defined: <a class="gl-ref" href="../glossary/#fsm" markdown="1">finite state machine</a>, <a class="gl-ref" href="../glossary/#literal" markdown="1">literal</a>, <a class="gl-ref" href="../glossary/#parser" markdown="1">parser</a>, <a class="gl-ref" href="../glossary/#precedence" markdown="1">precedence</a>, <a class="gl-ref" href="../glossary/#token" markdown="1">token</a>, <a class="gl-ref" href="../glossary/#turing_machine" markdown="1">Turing Machine</a>, <a class="gl-ref" href="../glossary/#well_formed" markdown="1">well formed</a>, <a class="gl-ref" href="../glossary/#yaml" markdown="1">YAML</a>
</p>


          <p>In <a class="x-ref" href="../pattern-matching/">Chapter 7</a> we created regular expressions by constructing objects.
It takes a lot less typing to write them as strings as we did for HTML selectors,
but if we&rsquo;re going to do that we need something to convert those strings to the required objects.
In other words, we need to write a <span class="ix-entry" ix-key="parser" markdown="1"><a class="gl-ref" href="../glossary/#parser" markdown="1">parser</a></span>.</p>
<div class="table"><table id="regex-parser-grammar-codes" class="table-here"><caption>Table 8.1: Regular expression grammar.</caption>
<thead>
<tr>
<th>Meaning</th>
<th>Character</th>
</tr>
</thead>
<tbody>
<tr>
<td>Any literal character <em>c</em></td>
<td><em>c</em></td>
</tr>
<tr>
<td>Beginning of input</td>
<td>^</td>
</tr>
<tr>
<td>End of input</td>
<td>$</td>
</tr>
<tr>
<td>Zero or more of the previous thing</td>
<td>*</td>
</tr>
<tr>
<td>Either/or</td>
<td>|</td>
</tr>
<tr>
<td>Grouping</td>
<td>(…)</td>
</tr>
</tbody>
</table>
</div>
<p><a class="tbl-ref" href="../regex-parser/#regex-parser-grammar-codes">Table 8.1</a> shows the grammar we will handle.
When we are done
we should be able to parse <code>/^(a|b|$)*z$/</code> as
&ldquo;start of text&rdquo;,
&ldquo;any number of &lsquo;a&rsquo;, &lsquo;b&rsquo;, or &lsquo;$&rsquo;&ldquo;,
&ldquo;a single &lsquo;z&rsquo;,
and &ldquo;end of text&rdquo;.
(We write regular expressions inside slashes to distinguish them from strings.)
To keep things simple,
we will create a tree of objects (<a class="fig-ref" href="../regex-parser/#regex-parser-expression-tree">Figure 8.1</a>)
rather than instances of the regular expression classes from <a class="x-ref" href="../pattern-matching/">Chapter 7</a>;
the exercises will tackle the latter.</p>
<figure id="regex-parser-expression-tree">
  <img src="./expression-tree.svg" alt="Expression tree for regular expression"/>
  <figcaption markdown="1">Figure 8.1: Representing the result of parsing a regular expression as an tree.</figcaption>
</figure>

<div class="callout">
<h3>Please don&rsquo;t write parsers</h3>
<p>Languages that are comfortable for people to read are usually difficult for computers to understand
and vice versa,
so we need parsers to translate human-friendly notation into computer-friendly representations.
However,
<span class="ix-entry" ix-key="parser!reasons not to write" markdown="1">the world doesn&rsquo;t need more file formats</span>;
if you need a configuration file or lookup table,
please use CSV, JSON, <a class="gl-ref" href="../glossary/#yaml" markdown="1">YAML</a>,
or something else that already has an acronym
rather than inventing a format of your own.</p>
</div>
<h2 id="regex-parser-tokenize">Section 8.2: How can we break text into tokens?</h2>
<p>A <span class="ix-entry" ix-key="token (in parsing)" markdown="1"><a class="gl-ref" href="../glossary/#token" markdown="1">token</a></span> is an atom of text,
such as the digits making up a number or the letters making up a variable name.
In our grammar the tokens are the special characters <code>*</code>, <code>|</code>, <code>(</code>, <code>)</code>, <code>^</code>, and <code>$</code>,
plus any sequence of one or more other characters (which count as one multi-letter token).
This classification guides the design of our parser:</p>
<ol>
<li>
<p>If a character is special, create a token for it.</p>
</li>
<li>
<p>If it is a <span class="ix-entry" ix-key="literal (in parsing)" markdown="1"><a class="gl-ref" href="../glossary/#literal" markdown="1">literal</a></span> then
    combine it with the current literal if there is one
    or start a new literal.</p>
</li>
<li>
<p>Since <code>^</code> and <code>$</code> are either special or regular depending on position,
    we must treat them as separate tokens or as part of a literal
    based on where they appear.</p>
</li>
</ol>
<p>We can translate these rules almost directly into code
to create a list of objects whose keys are <code>kind</code> and <code>loc</code> (short for location),
with the extra key <code>value</code> for literal values:</p>
<div class="code-sample lang-js" title="tokenizer-collapse.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">SIMPLE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="s1">&#39;*&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Any&#39;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="s1">&#39;|&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Alt&#39;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="s1">&#39;(&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;GroupStart&#39;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="s1">&#39;)&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;GroupEnd&#39;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">tokenize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">text</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">text</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">text</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">SIMPLE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="nx">SIMPLE</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;^&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Start&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">combineOrPush</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;$&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="p">(</span><span class="nx">text</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;End&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">combineOrPush</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">combineOrPush</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="nx">i</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">result</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">tokenize</span><span class="w"></span>
</code></pre></div>
</div>
<p>The helper function <code>combineOrPush</code> does exactly what its name says.
If the thing most recently added to the list of tokens isn&rsquo;t a literal,
the new character becomes a new token;
otherwise,
we append the new character to the literal we&rsquo;re building:</p>
<div class="code-sample lang-js" title="tokenizer-collapse.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">combineOrPush</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">soFar</span><span class="p">,</span><span class="w"> </span><span class="nx">character</span><span class="p">,</span><span class="w"> </span><span class="nx">location</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">topIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">soFar</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nx">soFar</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="nx">soFar</span><span class="p">[</span><span class="nx">topIndex</span><span class="p">].</span><span class="nx">token</span><span class="w"> </span><span class="o">!==</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">soFar</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="nx">character</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">location</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">soFar</span><span class="p">[</span><span class="nx">topIndex</span><span class="p">].</span><span class="nx">value</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nx">character</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</div>
<p>We can try this out with a three-line test program:</p>
<div class="code-sample lang-js" title="tokenizer-collapse-example.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">tokenize</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./tokenizer-collapse.js&#39;</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;^a^b*&#39;</span><span class="w"></span>
<span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">tokenize</span><span class="p">(</span><span class="nx">test</span><span class="p">)</span><span class="w"></span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w"> </span><span class="mf">2</span><span class="p">))</span><span class="w"></span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="tokenizer-collapse-example.out">
<div class="highlight"><pre><span></span><code>[
  {
    &quot;kind&quot;: &quot;Start&quot;,
    &quot;loc&quot;: 0
  },
  {
    &quot;kind&quot;: &quot;Lit&quot;,
    &quot;value&quot;: &quot;a&quot;,
    &quot;loc&quot;: 1
  },
  {
    &quot;kind&quot;: &quot;Lit&quot;,
    &quot;value&quot;: &quot;^&quot;,
    &quot;loc&quot;: 2
  },
  {
    &quot;kind&quot;: &quot;Lit&quot;,
    &quot;value&quot;: &quot;b&quot;,
    &quot;loc&quot;: 3
  },
  {
    &quot;kind&quot;: &quot;Any&quot;,
    &quot;loc&quot;: 4
  }
]
</code></pre></div>
</div>
<p>This simple tokenizer is readable, efficient, and wrong.
The problem is that the expression <code>/ab*/</code> means &ldquo;a single <code>a</code> followed by zero or more <code>b</code>&rdquo;.
If we combine the <code>a</code> and <code>b</code> as we read them,
though,
we wind up with &ldquo;zero or more repetitions of <code>ab</code>&rdquo;.
(Don&rsquo;t feel bad if you didn&rsquo;t spot this:
we didn&rsquo;t notice the problem until we were implementing the next step.)</p>
<p>The solution is to treat each regular character as its own literal in this stage
and then combine things later.
Doing this lets us get rid of the nested <code>if</code> for handling <code>^</code> and <code>$</code> as well:</p>
<div class="code-sample lang-js" title="tokenizer.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">SIMPLE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="s1">&#39;*&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Any&#39;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="s1">&#39;|&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Alt&#39;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="s1">&#39;(&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;GroupStart&#39;</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="s1">&#39;)&#39;</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;GroupEnd&#39;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">tokenize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">text</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">text</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">text</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">c</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nx">SIMPLE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="nx">SIMPLE</span><span class="p">[</span><span class="nx">c</span><span class="p">],</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nx">c</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;^&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Start&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="nx">c</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;$&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="nx">i</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="p">(</span><span class="nx">text</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;End&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="nx">i</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="p">})</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">result</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">tokenize</span><span class="w"></span>
</code></pre></div>
</div>
<p>Software isn&rsquo;t done until it&rsquo;s tested,
so let&rsquo;s build some <span class="ix-entry" ix-key="Mocha" markdown="1"><a href="https://mochajs.org/">Mocha</a></span> tests for our tokenizer.
The listing below shows a few of these
along with the output for the full set:</p>
<div class="code-sample lang-js" title="test-tokenizer.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">assert</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;assert&#39;</span><span class="w"></span>

<span class="k">import</span><span class="w"> </span><span class="nx">tokenize</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;../tokenizer.js&#39;</span><span class="w"></span>

<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;tokenizes correctly&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;tokenizes a single character&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">tokenize</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">])</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;tokenizes a sequence of characters&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">tokenize</span><span class="p">(</span><span class="s1">&#39;ab&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;b&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">])</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;tokenizes start anchor alone&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">tokenize</span><span class="p">(</span><span class="s1">&#39;^&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Start&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">])</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;tokenizes start anchor followed by characters&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">tokenize</span><span class="p">(</span><span class="s1">&#39;^a&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Start&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">])</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;tokenizes a complex expression&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">tokenize</span><span class="p">(</span><span class="s1">&#39;^a*(bcd|e^)*f$gh$&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Start&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Any&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">2</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;GroupStart&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">3</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;b&#39;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">5</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;c&#39;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">6</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;d&#39;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Alt&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">7</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">8</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;e&#39;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">9</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;^&#39;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;GroupEnd&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">10</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Any&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">11</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">12</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;f&#39;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">13</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;$&#39;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">14</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;g&#39;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">15</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;h&#39;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;End&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">16</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">])</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>
<span class="p">})</span><span class="w"></span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="tokenizer-test.out">
<div class="highlight"><pre><span></span><code>&gt; stjs@1.0.0 test /u/stjs
&gt; mocha */test/test-*.js &quot;-g&quot; &quot;tokenizes correctly&quot;



  tokenizes correctly
    ✓ tokenizes a single character
    ✓ tokenizes a sequence of characters
    ✓ tokenizes start anchor alone
    ✓ tokenizes start anchor followed by characters
    ✓ tokenizes circumflex not at start
    ✓ tokenizes start anchor alone
    ✓ tokenizes end anchor preceded by characters
    ✓ tokenizes dollar sign not at end
    ✓ tokenizes repetition alone
    ✓ tokenizes repetition in string
    ✓ tokenizes repetition at end of string
    ✓ tokenizes alternation alone
    ✓ tokenizes alternation in string
    ✓ tokenizes alternation at start of string
    ✓ tokenizes the start of a group alone
    ✓ tokenizes the start of a group in a string
    ✓ tokenizes the end of a group alone
    ✓ tokenizes the end of a group at the end of a string
    ✓ tokenizes a complex expression


  19 passing (12ms)
</code></pre></div>
</div>
<h2 id="regex-parser-tree">Section 8.3: How can we turn a list of tokens into a tree?</h2>
<p>We now have a list of tokens,
but we need a tree that captures the nesting introduced by parentheses
and the way that <code>*</code> applies to whatever comes before it.
Let&rsquo;s trace a few cases in order to see how to build this tree:</p>
<ol>
<li>
<p>If the regular expression is <code>/a/</code>, we create a <code>Lit</code> token for the letter <code>a</code>
    (where &ldquo;create&rdquo; means &ldquo;append to the output list&rdquo;).</p>
</li>
<li>
<p>What if the regular expression is <code>/a*/</code>?
    We first create a <code>Lit</code> token for the <code>a</code> and append it to the output list.
    When we see the <code>*</code>,
    we take that <code>Lit</code> token off the tail of the output list
    and replace it with an <code>Any</code> token that has the <code>Lit</code> token as its child.</p>
</li>
<li>
<p>Our next thought experiment is <code>/(ab)/</code>.
    We don&rsquo;t know how long the group is going to be when we see the <code>(</code>,
    so we put the parenthesis onto the output as a marker.
    We then add the <code>Lit</code> tokens for the <code>a</code> and <code>b</code>
    until we see the <code>)</code>,
    at which point we pull tokens off the end of the output list
    until we get back to the <code>(</code> marker.
    When we find it,
    we put everything we have temporarily collected into a <code>Group</code> token and append it to the output list.
    This algorithm automatically handles <code>/(a*)/</code> and <code>/(a(b*)c)/</code>.</p>
</li>
<li>
<p>What about <code>/a|b/</code>?
    We append a <code>Lit</code> token for <code>a</code>, get the <code>|</code> and&mdash;and we&rsquo;re stuck,
    because we don&rsquo;t yet have the next token we need to finish building the <code>Alt</code>.</p>
</li>
</ol>
<p class="continue">One way to solve this problem is to check if the thing on the top of the stack is waiting to combine
each time we append a new token.
However,
this doesn&rsquo;t handle <code>/a|b*/</code> properly.
The pattern is supposed to mean &ldquo;one <code>a</code> or any number of <code>b</code>&rdquo;,
but the <span class="ix-entry" ix-key="parser!check-and-combine" markdown="1">check-and-combine strategy</span> will turn it into the equivalent of <code>/(a|b)*/</code>.</p>
<p>A better (i.e., correct) solution is
to leave some partially-completed tokens in the output and <span class="ix-entry" ix-key="parser!post-hoc compression strategy" markdown="1">compress</span> them later
(<a class="fig-ref" href="../regex-parser/#regex-parser-mechanics">Figure 8.2</a>).
If our input is the pattern <code>/a|b/</code>, we can:</p>
<ol>
<li>
<p>Append a <code>Lit</code> token for <code>a</code>.</p>
</li>
<li>
<p>When we see <code>|</code>,
    make that <code>Lit</code> token the left child of the <code>Alt</code>
    and append that without filling in the right child.</p>
</li>
<li>
<p>Append the <code>Lit</code> token for <code>b</code>.</p>
</li>
<li>
<p>After all tokens have been handled,
    look for partially-completed <code>Alt</code> tokens and make whatever comes after them their right child.</p>
</li>
</ol>
<p class="continue">Again, this automatically handles patterns like <code>/(ab)|c*|(de)/</code>.</p>
<figure id="regex-parser-mechanics">
  <img src="./mechanics.svg" alt="Mechanics of combining tokens"/>
  <figcaption markdown="1">Figure 8.2: Mechanics of combining tokens while parsing regular expressions.</figcaption>
</figure>

<p>It&rsquo;s time to turn these ideas into code.
The main structure of our parser is:</p>
<div class="code-sample lang-js" title="parser.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">assert</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;assert&#39;</span><span class="w"></span>

<span class="k">import</span><span class="w"> </span><span class="nx">tokenize</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;./tokenizer.js&#39;</span><span class="w"></span>

<span class="kd">const</span><span class="w"> </span><span class="nx">parse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">text</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">allTokens</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">tokenize</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kd">let</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nx">allTokens</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">allTokens</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="w"></span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="nx">allTokens</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1</span><span class="w"></span>
<span class="w">    </span><span class="nx">handle</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">last</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">compress</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>


<span class="k">export</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="nx">parse</span><span class="w"></span>
</code></pre></div>
</div>
<p>We handle tokens case-by-case
(with a few assertions to check that patterns are <a class="gl-ref" href="../glossary/#well_formed" markdown="1">well formed</a>):</p>
<div class="code-sample lang-js" title="parser.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">handle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">token</span><span class="p">,</span><span class="w"> </span><span class="nx">last</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;Start&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">assert</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="s1">&#39;Should not have start token after other tokens&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;End&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">assert</span><span class="p">(</span><span class="nx">last</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="s1">&#39;Should not have end token before other tokens&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;GroupStart&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;GroupEnd&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">groupEnd</span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">token</span><span class="p">))</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;Any&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">assert</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="sb">`No operand for &#39;*&#39; (location </span><span class="si">${</span><span class="nx">token</span><span class="p">.</span><span class="nx">loc</span><span class="si">}</span><span class="sb">)`</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="nx">token</span><span class="p">.</span><span class="nx">child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">result</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;Alt&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">assert</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="sb">`No operand for &#39;*&#39; (location </span><span class="si">${</span><span class="nx">token</span><span class="p">.</span><span class="nx">loc</span><span class="si">}</span><span class="sb">)`</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="nx">token</span><span class="p">.</span><span class="nx">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">result</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="nx">token</span><span class="p">.</span><span class="nx">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="w"></span>
<span class="w">    </span><span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">assert</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;UNIMPLEMENTED&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</div>
<p>When we find the <code>)</code> that marks the end of a group,
we take items from the end of the output list
until we find the matching start
and use them to create a group:</p>
<div class="code-sample lang-js" title="parser.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">groupEnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">result</span><span class="p">,</span><span class="w"> </span><span class="nx">token</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Group&#39;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="kc">null</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nx">end</span><span class="o">:</span><span class="w"> </span><span class="nx">token</span><span class="p">.</span><span class="nx">loc</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="nx">children</span><span class="o">:</span><span class="w"> </span><span class="p">[]</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">assert</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"></span>
<span class="w">           </span><span class="sb">`Unmatched end parenthesis (location </span><span class="si">${</span><span class="nx">token</span><span class="p">.</span><span class="nx">loc</span><span class="si">}</span><span class="sb">)`</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">result</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">child</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;GroupStart&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">group</span><span class="p">.</span><span class="nx">loc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">child</span><span class="p">.</span><span class="nx">loc</span><span class="w"></span>
<span class="w">      </span><span class="k">break</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="nx">group</span><span class="p">.</span><span class="nx">children</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nx">child</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">group</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</div>
<p>Finally,
when we have finished with the input,
we go through the output list one last time to fill in the right side of <code>Alt</code>s:</p>
<div class="code-sample lang-js" title="parser.js">
<div class="highlight"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">compress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">raw</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">cooked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[]</span><span class="w"></span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nx">raw</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">token</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">raw</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="nx">kind</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;Alt&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="nx">assert</span><span class="p">(</span><span class="nx">cooked</span><span class="p">.</span><span class="nx">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"></span>
<span class="w">             </span><span class="sb">`No right operand for alt (location </span><span class="si">${</span><span class="nx">token</span><span class="p">.</span><span class="nx">loc</span><span class="si">}</span><span class="sb">)`</span><span class="p">)</span><span class="w"></span>
<span class="w">      </span><span class="nx">token</span><span class="p">.</span><span class="nx">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">cooked</span><span class="p">.</span><span class="nx">shift</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="nx">cooked</span><span class="p">.</span><span class="nx">unshift</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span><span class="w"></span>
<span class="w">  </span><span class="p">}</span><span class="w"></span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">cooked</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>
</div>
<p>Once again,
it&rsquo;s not done until we&rsquo;ve tested it:</p>
<div class="code-sample lang-js" title="test-parser.js">
<div class="highlight"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="nx">assert</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;assert&#39;</span><span class="w"></span>

<span class="k">import</span><span class="w"> </span><span class="nx">parse</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s1">&#39;../parser.js&#39;</span><span class="w"></span>

<span class="nx">describe</span><span class="p">(</span><span class="s1">&#39;parses correctly&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;parses the empty string&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">parse</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[])</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;parses a single literal&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">parse</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">])</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>

<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;parses multiple literals&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">parse</span><span class="p">(</span><span class="s1">&#39;ab&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;b&#39;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">])</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>


<span class="w">  </span><span class="nx">it</span><span class="p">(</span><span class="s1">&#39;parses alt of groups&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nx">assert</span><span class="p">.</span><span class="nx">deepStrictEqual</span><span class="p">(</span><span class="nx">parse</span><span class="p">(</span><span class="s1">&#39;a|(bc)&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">      </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Alt&#39;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="nx">left</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">0</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;a&#39;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="nx">right</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">          </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Group&#39;</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">2</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="nx">end</span><span class="o">:</span><span class="w"> </span><span class="mf">5</span><span class="p">,</span><span class="w"></span>
<span class="w">          </span><span class="nx">children</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">3</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;b&#39;</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="nx">kind</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;Lit&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="o">:</span><span class="w"> </span><span class="mf">4</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;c&#39;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">          </span><span class="p">]</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">])</span><span class="w"></span>
<span class="w">  </span><span class="p">})</span><span class="w"></span>
<span class="p">})</span><span class="w"></span>
</code></pre></div>
</div>
<div class="code-sample lang-out" title="parser-test.out">
<div class="highlight"><pre><span></span><code>&gt; stjs@1.0.0 test /u/stjs
&gt; mocha */test/test-*.js &quot;-g&quot; &quot;parses correctly&quot;



  parses correctly
    ✓ parses the empty string
    ✓ parses a single literal
    ✓ parses multiple literals
    ✓ parses start anchors
    ✓ handles circumflex not at start
    ✓ parses end anchors
    ✓ parses circumflex not at start
    ✓ parses empty groups
    ✓ parses groups containing characters
    ✓ parses two groups containing characters
    ✓ parses any
    ✓ parses any of group
    ✓ parses alt
    ✓ parses alt of any
    ✓ parses alt of groups


  15 passing (11ms)
</code></pre></div>
</div>
<p>While our final parser is less than 90 lines of code,
it is doing a lot of complex things.
Compared to parsers for things like JSON and YAML,
though,
it is still very simple.
If we have more operators with different <span class="ix-entry" ix-key="operator precedence!implementing" markdown="1"><a class="gl-ref" href="../glossary/#precedence" markdown="1">precedences</a></span>
we should switch to the <span class="ix-entry" ix-key="shunting-yard algorithm;parser!shunting-yard algorithm" markdown="1"><a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting-yard algorithm</a></span>,
and if we need to handle a language like JavaScript we should explore tools like <span class="ix-entry" ix-key="ANTLR" markdown="1"><a href="https://www.antlr.org/">ANTLR</a></span>,
which can generate a parser automatically given a description of the language to be parsed.
As we said at the start,
though,
if our design requires us to write a parser we should try to come up with a better design.
CSV, JSON, YAML, and other formats <a href="https://third-bit.com/2015/06/11/why-we-cant-have-nice-things/">have their quirks</a>,
but at least they&rsquo;re broken the same way everywhere.</p>
<div class="callout">
<h3>The limits of computing</h3>
<p>One of the most important theoretical results in computer science is that
every formal language corresponds to a type of abstract machine and vice versa,
and that some languages (or machines) are more or less powerful than others.
For example,
every regular expression corresponds to a <span class="ix-entry" ix-key="finite state machine!correspondence with regular expressions" markdown="1"><a class="gl-ref" href="../glossary/#fsm" markdown="1">finite state machine</a></span> (FSM)
like the one in <a class="fig-ref" href="../regex-parser/#regex-parser-finite-state-machine">Figure 8.3</a>.
As powerful as FSMs are,
they cannot match things like nested parentheses or HTML tags,
and <span class="ix-entry" ix-key="sin!using regular expressions to parse HTML" markdown="1"><a href="https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454">attempting to do so is a sin</a></span>.
If you add a stack to the system you can process a much richer set of languages,
and if you add two stacks you have something equivalent to a <span class="ix-entry" ix-key="Turing Machine" markdown="1"><a class="gl-ref" href="../glossary/#turing_machine" markdown="1">Turing Machine</a></span>
that can do any conceivable computation.
<span class="bib-ref">[<a class="bib-ref" href="../bibliography/#Conery2021">Conery2021</a>]</span> presents this idea and others for self-taught developers.</p>
</div>
<figure id="regex-parser-finite-state-machine">
  <img src="./finite-state-machine.svg" alt="Finite state machine"/>
  <figcaption markdown="1">Figure 8.3: A finite state machine equivalent to a regular expression.</figcaption>
</figure>

<h2 id="regex-parser-exercises">Section 8.4: Exercises</h2>
<h3 class="exercise">Create objects</h3>
<p>Modify the parser to return instances of classes derived from <code>RegexBase</code>.</p>
<h3 class="exercise">Escape characters</h3>
<p>Modify the parser to handle escape characters,
so that (for example) <code>\*</code> is interpreted as &ldquo;a literal asterisk&rdquo;
and <code>\\</code> is interpreted as &ldquo;a literal backslash&rdquo;.</p>
<h3 class="exercise">Lazy matching</h3>
<p>Modify the parser so that <code>*?</code> is interpreted as a single token
meaning &ldquo;lazy match zero or more&rdquo;.</p>
<h3 class="exercise">Character sets</h3>
<p>Modify the parser so that expressions like <code>[xyz]</code> are interpreted to mean
&ldquo;match any one of the characters x, y, or z&rdquo;.</p>
<h3 class="exercise">Back reference</h3>
<p>Modify the tokenizer so that it recognizes <code>\1</code>, <code>\2</code>, and so on to mean &ldquo;back reference&rdquo;.
The number may contain any number of digits.</p>
<h3 class="exercise">Named groups</h3>
<ol>
<li>
<p>Modify the tokenizer to recognize named groups.
    For example, the named group <code>/(?&lt;triple&gt;aaa)/</code>
    would create a named group called <code>triple</code> that matches exactly three consecutive occurrences of &lsquo;a&rsquo;.</p>
</li>
<li>
<p>Write Mocha tests for your modified tokenizer.
    Does it handle nested named groups?</p>
</li>
</ol>
<h3 class="exercise">Object streams</h3>
<p>Write a parser that turns files of key-value pairs separated by blank lines into objects.
For example, if the input is:</p>
<div class="highlight"><pre><span></span><code>left: &quot;left value&quot;
first: 1

middle: &quot;middle value&quot;
second: 2

right: &quot;right value&quot;
third: 3
</code></pre></div>
<p class="continue">then the output will be:</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="nx">left</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;left value&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">first</span><span class="o">:</span><span class="w"> </span><span class="mf">1</span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="nx">middle</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;middle value&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">second</span><span class="o">:</span><span class="w"> </span><span class="mf">2</span><span class="p">},</span><span class="w"></span>
<span class="w">  </span><span class="p">{</span><span class="nx">right</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;right value&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">third</span><span class="o">:</span><span class="w"> </span><span class="mf">3</span><span class="p">}</span><span class="w"></span>
<span class="p">]</span><span class="w"></span>
</code></pre></div>
<p>Keys are always upper- and lower-case characters;
values may be strings in double quotes or unquoted numbers.</p>
<h3 class="exercise">Tokenize HTML</h3>
<ol>
<li>
<p>Write a tokenizer for a subset of HTML that consists of:</p>
<ul>
<li>Opening tags without attributes, such as <code>&lt;div&gt;</code> and <code>&lt;p&gt;</code></li>
<li>Closing tags, such as <code>&lt;/p&gt;</code> and <code>&lt;/div&gt;</code></li>
<li>Plain text between tags that does <em>not</em> contain &lsquo;&lt;&rsquo; or &lsquo;&gt;&rsquo; characters</li>
</ul>
</li>
<li>
<p>Modify the tokenizer to handle <code>key="value"</code> attributes in opening tags.</p>
</li>
<li>
<p>Write Mocha tests for your tokenizer.</p>
</li>
</ol>
<h3 class="exercise">The Shunting-Yard Algorithm</h3>
<ol>
<li>
<p>Use the <a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">shunting-yard algorithm</a>
    to implement a tokenizer for a simple subset of arithmetic that includes:</p>
<ul>
<li>single-letter variable names</li>
<li>single-digit numbers</li>
<li>the <code>+</code>, <code>*</code>, and <code>^</code> operators, where <code>+</code> has the lowest precedence and <code>^</code> has the highest</li>
</ul>
</li>
<li>
<p>Write Mocha tests for your tokenizer.</p>
</li>
</ol>
<h3 class="exercise">Handling errors</h3>
<ol>
<li>
<p>What does the regular expression tokenizer do
    with expressions that contain unmatched opening parentheses like <code>/a(b/</code>?
    What about expressions that contain unmatched closing parentheses like <code>/ab)/</code>?</p>
</li>
<li>
<p>Modify it so it produces a more useful error message.</p>
</li>
</ol>
        </main>
      </div>
    </div>
  </body>
</html>
